//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CategoriaViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Método para obtener una categoría por una id en específico
     * @param id (optional) Identificador único de la categoría
     */
    obtenerCategoriaPorId(id: string | undefined, area: string): Observable<ObtenerCategoriasViajePadreRespuesta> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriaPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerCategoriasViajePadreRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerCategoriasViajePadreRespuesta>;
        }));
    }

    protected processObtenerCategoriaPorId(response: HttpResponseBase): Observable<ObtenerCategoriasViajePadreRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerCategoriasViajePadreRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de categorias", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método que obtiene la cagoterías registras, preparadas para un dxDataGrid DevExtreme
     * @param options (optional) Opciones filtrado de tipo DataSourceLoadOptions
     */
    obtenerCategoriasGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerCategoriasGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de categorias", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para obtener todas las categorias de viaje que son padres
     */
    obtenerCategoriasViajePadre(area: string): Observable<ObtenerCategoriasViajePadreRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasViajePadre";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasViajePadre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasViajePadre(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerCategoriasViajePadreRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerCategoriasViajePadreRespuesta[]>;
        }));
    }

    protected processObtenerCategoriasViajePadre(response: HttpResponseBase): Observable<ObtenerCategoriasViajePadreRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerCategoriasViajePadreRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de categorias", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerCategoriasViajePadreCombo(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasViajePadreCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasViajePadreCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasViajePadreCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerCategoriasViajePadreCombo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de categorias", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todas las categorias de viaje que son padres
     * @param id (optional) Identificador único de la categoría
     */
    obtenerCategoriasViajeHijas(id: string | undefined, area: string): Observable<ObtenerCategoriasViajeHijasRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasViajeHijas?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasViajeHijas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasViajeHijas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerCategoriasViajeHijasRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerCategoriasViajeHijasRespuesta[]>;
        }));
    }

    protected processObtenerCategoriasViajeHijas(response: HttpResponseBase): Observable<ObtenerCategoriasViajeHijasRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerCategoriasViajeHijasRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de categorias", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para registrar una nueva categoría
     * @param peticion Datos de la nueva catgoría
     */
    registrarCategoria(peticion: RegistrarCategoriaViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/RegistrarCategoria";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarCategoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarCategoria(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para registrar una nueva categoría
     * @param peticion Datos de la categoría
     */
    editarCategoria(peticion: EditarCategoriaViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/EditarCategoria";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarCategoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarCategoria(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para eliminar una categoría
     * @param id (optional) Identificador unico de la categoria
     */
    eliminarCategoria(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/EliminarCategoria?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarCategoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarCategoria(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerCategoriasViajePadrePaginadas(search: string | null | undefined, page: number | null | undefined, area: string): Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasViajePadrePaginadas?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasViajePadrePaginadas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasViajePadrePaginadas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta>;
        }));
    }

    protected processObtenerCategoriasViajePadrePaginadas(response: HttpResponseBase): Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerCategoriasViajeHijasPaginadas(id: string | undefined, search: string | null | undefined, page: number | null | undefined, area: string): Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasViajeHijasPaginadas?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasViajeHijasPaginadas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasViajeHijasPaginadas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta>;
        }));
    }

    protected processObtenerCategoriasViajeHijasPaginadas(response: HttpResponseBase): Observable<ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerCategoriasTagBox(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasTagBox";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasTagBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasTagBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerCategoriasTagBox(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerCategoriasAsociadasViaje(viajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerCategoriasAsociadasViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoriasAsociadasViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoriasAsociadasViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerCategoriasAsociadasViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSubcategoriasAsociadasViaje(viajeId: string | undefined, categoriaViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/CategoriaViaje/ObtenerSubcategoriasAsociadasViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (categoriaViajeId === null)
            throw new Error("The parameter 'categoriaViajeId' cannot be null.");
        else if (categoriaViajeId !== undefined)
            url_ += "categoriaViajeId=" + encodeURIComponent("" + categoriaViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSubcategoriasAsociadasViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSubcategoriasAsociadasViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerSubcategoriasAsociadasViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoriaViajeImagenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    subirCategoriaViajeImagenTemporal(imagenCategoria: FileParameter | null | undefined, area: string): Observable<RespuestaGuardadoArchivoTemporal> {
        let url_ = this.baseUrl + "/{area}/CategoriaViajeImagen/SubirCategoriaViajeImagenTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imagenCategoria !== null && imagenCategoria !== undefined)
            content_.append("imagenCategoria", imagenCategoria.data, imagenCategoria.fileName ? imagenCategoria.fileName : "imagenCategoria");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirCategoriaViajeImagenTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirCategoriaViajeImagenTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RespuestaGuardadoArchivoTemporal>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RespuestaGuardadoArchivoTemporal>;
        }));
    }

    protected processSubirCategoriaViajeImagenTemporal(response: HttpResponseBase): Observable<RespuestaGuardadoArchivoTemporal> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RespuestaGuardadoArchivoTemporal;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChoferClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Método para registrar un chofer/transportista en base de datos
     * @param peticion Datos del chofer
     * @return Id del chofer registrado
     */
    registrarChofer(peticion: RegistrarChoferPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Chofer/RegistrarChofer";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarChofer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarChofer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarChofer(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir un chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de registro correctamente", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de registrar el chofer", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de un chofer a través de su identificador
     * @param id (optional) Id del chofer
     * @return Información del chofer solicitado para vista administración
     */
    obtenerChoferPorIdAdmin(id: string | undefined, area: string): Observable<ObtenerChoferPorIdAdminRespuesta> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferPorIdAdmin?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferPorIdAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferPorIdAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerChoferPorIdAdminRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerChoferPorIdAdminRespuesta>;
        }));
    }

    protected processObtenerChoferPorIdAdmin(response: HttpResponseBase): Observable<ObtenerChoferPorIdAdminRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerChoferPorIdAdminRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n del chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la informaci\u00f3n del chofer con el id enviado", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de obtener la informaci\u00f3n del chofer", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de un chofer a través de su identificador
     * @param id (optional) Id del chofer
     * @return Información del chofer solicitado
     */
    obtenerChoferPorId(id: string | undefined, area: string): Observable<ConsultaChoferRespuesta> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultaChoferRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultaChoferRespuesta>;
        }));
    }

    protected processObtenerChoferPorId(response: HttpResponseBase): Observable<ConsultaChoferRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConsultaChoferRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n del chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la informaci\u00f3n del chofer con el id enviado", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de obtener la informaci\u00f3n del chofer", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el listado de choferes para un data grid
     * @param options (optional) 
     * @return Listado de choferes para mostrar en un grid de DevExtreme
     */
    obtenerChoferesDataGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesDataGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesDataGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesDataGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerChoferesDataGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si ocurre un error al obtener el listado", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el listado de choferes para un Id de transportista en expecifico para un data grid devexpress
     * @param options (optional) 
     * @param transportistaId (optional) 
     * @return Listado de choferes para mostrar en un grid de DevExtreme
     */
    obtenerChoferesPorIdDataGrid(options: DataSourceLoadOptions | null | undefined, transportistaId: string | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesPorIdDataGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        if (transportistaId === null)
            throw new Error("The parameter 'transportistaId' cannot be null.");
        else if (transportistaId !== undefined)
            url_ += "transportistaId=" + encodeURIComponent("" + transportistaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesPorIdDataGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesPorIdDataGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerChoferesPorIdDataGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si ocurre un error al obtener el listado", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite editar los datos de un chofer
     * @param peticion Nuevos datos del chofer
     * @return Id del chofer editado
     */
    editarChofer(peticion: EditarChoferPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Chofer/EditarChofer";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarChofer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarChofer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarChofer(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para editar un chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de edici\u00f3n correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el chofer que se va a editar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de editar el chofer", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina un chofer
     * @param id (optional) Id del chofer
     * @return Cuando el chofer ha sido eliminado correctamente
     */
    eliminarChofer(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Chofer/EliminarChofer?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarChofer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarChofer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarChofer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para eliminar un chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si no se env\u00eda el id del chofer a eliminar", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el chofer que se va a eliminar con el id prporcionador", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de eliminar el chofer", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todos los cheferes asignados a un usuario en especifico.
     * @param id (optional) Identificador unico del usuario
     * @return Listado de choferes
     */
    obtenerChoferesPorUsuario(id: string | null | undefined, area: string): Observable<ObtenerChoferesPorUsuarioRespuesta> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesPorUsuario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesPorUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesPorUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerChoferesPorUsuarioRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerChoferesPorUsuarioRespuesta>;
        }));
    }

    protected processObtenerChoferesPorUsuario(response: HttpResponseBase): Observable<ObtenerChoferesPorUsuarioRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerChoferesPorUsuarioRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para visualizar el contenido", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todos los cheferes asignados a un transportista en especifico.
     * @param id (optional) Identificador unico del transportista
     * @return Listado de choferes
     */
    obtenerChoferesPorTransportista(id: string | undefined, area: string): Observable<ObtenerChoferesPorUsuarioRespuesta> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesPorTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesPorTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesPorTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerChoferesPorUsuarioRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerChoferesPorUsuarioRespuesta>;
        }));
    }

    protected processObtenerChoferesPorTransportista(response: HttpResponseBase): Observable<ObtenerChoferesPorUsuarioRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerChoferesPorUsuarioRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para visualizar el contenido", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Valida un chofer
     * @param choferId (optional) 
     * @return Cuando el chofer ha sido validado correctamente
     */
    validarChofer(choferId: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Chofer/ValidarChofer?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (choferId === null)
            throw new Error("The parameter 'choferId' cannot be null.");
        else if (choferId !== undefined)
            url_ += "choferId=" + encodeURIComponent("" + choferId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidarChofer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidarChofer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidarChofer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para validar un chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si no se env\u00eda el id del chofer a validar", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el chofer que se va a validar con el id proporcionado", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de validar el chofer", status, _responseText, _headers, result500);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si el chofer ya se encuentra validado", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerChoferesCombo(area: string): Observable<ChoferComboRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferComboRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferComboRespuesta[]>;
        }));
    }

    protected processObtenerChoferesCombo(response: HttpResponseBase): Observable<ChoferComboRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferComboRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el listado de choferes para un data grid
     * @param options (optional) 
     * @return Listado de choferes para mostrar en un grid de DevExtreme
     */
    obtenerChoferesAdminDataGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Chofer/ObtenerChoferesAdminDataGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerChoferesAdminDataGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerChoferesAdminDataGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerChoferesAdminDataGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si ocurre un error al obtener el listado", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChoferImagenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Ruta para subir la imagen de perfil de un chofer
     * @param imgperfil (optional) Archivo de la imagen de perfil, formatos admitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirImagenPerfil(imgperfil: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/ChoferImagen/SubirImagenPerfil";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imgperfil !== null && imgperfil !== undefined)
            content_.append("imgperfil", imgperfil.data, imgperfil.fileName ? imgperfil.fileName : "imgperfil");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenPerfil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenPerfil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirImagenPerfil(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para subir la foto frontal de la credencial de elector INE
     * @param imginefrente (optional) Archivo de la imagen frontal de la credencial INE, formatos admitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirIfeFrontal(imginefrente: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/ChoferImagen/SubirIfeFrontal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imginefrente !== null && imginefrente !== undefined)
            content_.append("imginefrente", imginefrente.data, imginefrente.fileName ? imginefrente.fileName : "imginefrente");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirIfeFrontal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirIfeFrontal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirIfeFrontal(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para subir la foto del reverso de la credencial de elector INE
     * @param imginereverso (optional) Archivo de la imagen del reverso de la credencial INE, formatos admitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirIfeReverso(imginereverso: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/ChoferImagen/SubirIfeReverso";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imginereverso !== null && imginereverso !== undefined)
            content_.append("imginereverso", imginereverso.data, imginereverso.fileName ? imginereverso.fileName : "imginereverso");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirIfeReverso(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirIfeReverso(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirIfeReverso(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para subir la foto frontal de la licencia de conducir de un chofer
     * @param imglicenciafrente (optional) Archivo de la imagen frontal de la licencia de conducir, formatos admitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirLicenciaFrontal(imglicenciafrente: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/ChoferImagen/SubirLicenciaFrontal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imglicenciafrente !== null && imglicenciafrente !== undefined)
            content_.append("imglicenciafrente", imglicenciafrente.data, imglicenciafrente.fileName ? imglicenciafrente.fileName : "imglicenciafrente");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirLicenciaFrontal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirLicenciaFrontal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirLicenciaFrontal(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para subir la foto del reverso de la licencia de conducir de un chofer
     * @param imglicenciareverso (optional) Archivo de la imagen frontal de la licencia de conducir, formatos admitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirLicenciaReverso(imglicenciareverso: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/ChoferImagen/SubirLicenciaReverso";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imglicenciareverso !== null && imglicenciareverso !== undefined)
            content_.append("imglicenciareverso", imglicenciareverso.data, imglicenciareverso.fileName ? imglicenciareverso.fileName : "imglicenciareverso");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirLicenciaReverso(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirLicenciaReverso(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirLicenciaReverso(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de chofer", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContactoEmergenciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite obtener la información de un contacto de emergencia a través de su identificador de base de datos
     * @param id (optional) Identificador del base de datos
     * @return Información del contacto de emergencia solicitado
     */
    obtenerContactoEmergenciaPorId(id: string | undefined, area: string): Observable<ContactoEmergenciaRespuesta> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/ObtenerContactoEmergenciaPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerContactoEmergenciaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerContactoEmergenciaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactoEmergenciaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactoEmergenciaRespuesta>;
        }));
    }

    protected processObtenerContactoEmergenciaPorId(response: HttpResponseBase): Observable<ContactoEmergenciaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactoEmergenciaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n del contacto de emergencia", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si se env\u00eda un id inv\u00e1lido", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la informaci\u00f3n del dispositivo m\u00f3v con el id enviado", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de obtener la informaci\u00f3n del contacto de emergencia", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Recupera información de los dispositivos móviles de un usuario
     * @param usuarioId (optional) Identificador del usuario
     * @return Listado de contactos de emergencia del usuario solicitado
     */
    obtenerContactosEmergenciaPorUsuarioId(usuarioId: string | null | undefined, area: string): Observable<ContactoEmergenciaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/ObtenerContactosEmergenciaPorUsuarioId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerContactosEmergenciaPorUsuarioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerContactosEmergenciaPorUsuarioId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactoEmergenciaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactoEmergenciaRespuesta[]>;
        }));
    }

    protected processObtenerContactosEmergenciaPorUsuarioId(response: HttpResponseBase): Observable<ContactoEmergenciaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactoEmergenciaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando existe un error al tratar de cargar la lista de dispositivos m\u00f3viles", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para registrar un contacto de emergencia
     * @param peticion Datos del nuevo contacto de emergencia
     * @return Id del contacto de emergencia registrado
     */
    registrar(peticion: ContactoEmergenciaRegistrarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/Registrar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrar(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para registrar un contacto de emergencia", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de registro correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el contacto de emergencia que se va a registrar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de registrar el contacto de emergencia", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite modificar la información de un contacto de emergencia
     * @param peticion Nueva información para el contacto de emergencia que se edita
     * @return Id del contacto de emergencia editado
     */
    editar(peticion: ContactoEmergenciaEditarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/Editar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditar(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para editar un contacto de emergencia", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de edici\u00f3n correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el contacto de emergencia que se va a editar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de editar el contacto de emergencia", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite remover la información de un contacto de emergencia
     * @param id (optional) Identificador del contacto de emergencia a eliminar
     * @return Cuando el contacto de emergencia ha sido eliminado correctamente
     */
    eliminar(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/Eliminar?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para eliminar un contacto de emergencia", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si no se env\u00eda el id del contacto de emergencia a eliminar", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el contacto de emergencia que se va a eliminar con el id prporcionador", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de eliminar el contacto de emergencia", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enviarNotificacionEmergenciaTwilio(idUsuario: string | null | undefined, contenido: string | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/ContactoEmergencia/EnviarNotificacionEmergenciaTwilio?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUsuario !== undefined && idUsuario !== null)
            url_ += "idUsuario=" + encodeURIComponent("" + idUsuario) + "&";
        if (contenido !== undefined && contenido !== null)
            url_ += "contenido=" + encodeURIComponent("" + contenido) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarNotificacionEmergenciaTwilio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarNotificacionEmergenciaTwilio(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEnviarNotificacionEmergenciaTwilio(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DatoFacturacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Metodo que registra un dato de facturación
     */
    registrarDatoFacturacion(peticion: RegistrarDatoFacturacionPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/DatoFacturacion/RegistrarDatoFacturacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarDatoFacturacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarDatoFacturacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarDatoFacturacion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para editar un dato de facturación
     */
    editarDatoFacturacion(peticion: EditarDatoFacturacionPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/DatoFacturacion/EditarDatoFacturacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarDatoFacturacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarDatoFacturacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEditarDatoFacturacion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuleve los datos de facturación para un usuario en especifico
     * @param usuarioId (optional) 
     */
    obtenerDatosDeFacturacion(usuarioId: string | null | undefined, area: string): Observable<ObtenerDatosFacturacionRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/DatoFacturacion/ObtenerDatosDeFacturacion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosDeFacturacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosDeFacturacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDatosFacturacionRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDatosFacturacionRespuesta[]>;
        }));
    }

    protected processObtenerDatosDeFacturacion(response: HttpResponseBase): Observable<ObtenerDatosFacturacionRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDatosFacturacionRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los datos de facturación para un DataGrid DevExtreme
     * @param options (optional) 
     */
    obtenerDatosFacturacionGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/DatoFacturacion/ObtenerDatosFacturacionGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosFacturacionGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosFacturacionGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerDatosFacturacionGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para eliminar un datos de facturación en especifico.
     * @param datoFacturacionId (optional) 
     */
    eliminar(datoFacturacionId: string | undefined, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/DatoFacturacion/Eliminar?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (datoFacturacionId === null)
            throw new Error("The parameter 'datoFacturacionId' cannot be null.");
        else if (datoFacturacionId !== undefined)
            url_ += "datoFacturacionId=" + encodeURIComponent("" + datoFacturacionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEliminar(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DevolucionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerDetallesDevolucionOpenpay(solicitudViajePagoOpenpayId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Devolucion/ObtenerDetallesDevolucionOpenpay?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajePagoOpenpayId === null)
            throw new Error("The parameter 'solicitudViajePagoOpenpayId' cannot be null.");
        else if (solicitudViajePagoOpenpayId !== undefined)
            url_ += "solicitudViajePagoOpenpayId=" + encodeURIComponent("" + solicitudViajePagoOpenpayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesDevolucionOpenpay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesDevolucionOpenpay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerDetallesDevolucionOpenpay(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    iniciarDevolucionOpenpay(peticion: IniciarDevolucionOpenpayPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Devolucion/IniciarDevolucionOpenpay";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIniciarDevolucionOpenpay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIniciarDevolucionOpenpay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processIniciarDevolucionOpenpay(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DispositivoMovilClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite obtener la información de un dispositivo móvil a través de su identificador de base de datos
     * @param id (optional) Identificador del base de datos
     * @return Información del dispositivo móvil solicitado
     */
    obtenerDispositivoMovilPorId(id: string | undefined, area: string): Observable<DispositivoMovilRespuesta> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/ObtenerDispositivoMovilPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDispositivoMovilPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDispositivoMovilPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DispositivoMovilRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DispositivoMovilRespuesta>;
        }));
    }

    protected processObtenerDispositivoMovilPorId(response: HttpResponseBase): Observable<DispositivoMovilRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DispositivoMovilRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n del dispositivo m\u00f3vil", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si se env\u00eda un id inv\u00e1lido", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la informaci\u00f3n del dispositivo m\u00f3v con el id enviado", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de obtener la informaci\u00f3n del dispositivo m\u00f3vil", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el listado de dispositivos móviles para servir en un grid de devextreme
     * @param options (optional) 
     * @return Listado de dispositivos móviles para el grid de DevExtreme
     */
    obtenerDispositivosMovilesGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/ObtenerDispositivosMovilesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDispositivosMovilesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDispositivosMovilesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerDispositivosMovilesGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando existe un error al tratar de cargar la lista de dispositivos m\u00f3viles", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Recupera información de los dispositivos móviles de un usuario
     * @param usuarioId (optional) Identificador del usuario
     * @return Listado de dispositivos móviles del usuario solicitado
     */
    obtenerDispositivosMovilesPorUsuarioId(usuarioId: string | null | undefined, area: string): Observable<DispositivoMovilRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/ObtenerDispositivosMovilesPorUsuarioId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDispositivosMovilesPorUsuarioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDispositivosMovilesPorUsuarioId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DispositivoMovilRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DispositivoMovilRespuesta[]>;
        }));
    }

    protected processObtenerDispositivosMovilesPorUsuarioId(response: HttpResponseBase): Observable<DispositivoMovilRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DispositivoMovilRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando existe un error al tratar de cargar la lista de dispositivos m\u00f3viles", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta para registrar un dispositivo móvil
     * @param peticion Datos del nuevo dispositivo móvil
     * @return Id del dispositivo móvil registrado
     */
    registrar(peticion: DispositivoMovilRegistrarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/Registrar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrar(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para registrar un dispositivo m\u00f3vil", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de registro correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el dispositivo m\u00f3vil que se va a registrar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de registrar el dispositivo m\u00f3vil", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite modificar la información de un dispositivo móvil
     * @param peticion Nueva información para el dispositivo móvil que se edita
     * @return Id del dispositivo móvil editado
     */
    editar(peticion: DispositivoMovilEditarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/Editar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditar(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para editar un dispositivo m\u00f3vil", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de edici\u00f3n correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el dispositivo m\u00f3vil que se va a editar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de editar el dispositivo m\u00f3vil", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite remover la información de un dispositivo móvil
     * @param id (optional) Identificador del dispositivo móvil a eliminar
     * @return Cuando el dispositivo móvil ha sido eliminado correctamente
     */
    eliminar(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/Eliminar?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para eliminar un dispositivo m\u00f3vil", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si no se env\u00eda el id del dispositivo m\u00f3vil a eliminar", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el dispositivo m\u00f3vil que se va a eliminar con el id prporcionador", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de eliminar el dispositivo m\u00f3vil", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enviarNotificacionEmergencia(titulo: string | null | undefined, contenido: string | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/DispositivoMovil/EnviarNotificacionEmergencia?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (titulo !== undefined && titulo !== null)
            url_ += "titulo=" + encodeURIComponent("" + titulo) + "&";
        if (contenido !== undefined && contenido !== null)
            url_ += "contenido=" + encodeURIComponent("" + contenido) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarNotificacionEmergencia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarNotificacionEmergencia(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEnviarNotificacionEmergencia(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentoSolicitudClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    registrarDocumentoSolicitud(peticion: RegistrarDocumentoSolicitudPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/DocumentoSolicitud/RegistrarDocumentoSolicitud";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarDocumentoSolicitud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarDocumentoSolicitud(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarDocumentoSolicitud(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarDocumentoSolicitud(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/DocumentoSolicitud/EliminarDocumentoSolicitud?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarDocumentoSolicitud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarDocumentoSolicitud(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarDocumentoSolicitud(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDocumentosSolicitud(id: string | undefined, area: string): Observable<DocumentoSolicitudRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/DocumentoSolicitud/ObtenerDocumentosSolicitud?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDocumentosSolicitud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDocumentosSolicitud(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentoSolicitudRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentoSolicitudRespuesta[]>;
        }));
    }

    protected processObtenerDocumentosSolicitud(response: HttpResponseBase): Observable<DocumentoSolicitudRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DocumentoSolicitudRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FacturacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite facturar una venta
     * @param peticion Datos de la venta, cliente, establecimiento, etc
     * @return Respuesta con datos del proceso de timbrado de la factura
     */
    timbrarVentaPeticion(peticion: TimbrarVentaPeticion, area: string): Observable<TimbrarServiceResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/TimbrarVentaPeticion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimbrarVentaPeticion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimbrarVentaPeticion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimbrarServiceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimbrarServiceResponse>;
        }));
    }

    protected processTimbrarVentaPeticion(response: HttpResponseBase): Observable<TimbrarServiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimbrarServiceResponse;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Respuesta devuelta en caso de no enviar los datos requeridos en la petici\u00f3n de timbrado", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener el XML de un Cfdi a través de su CfdGuid
     * @param cfdGuid (optional) 
     * @return XML codificado en base64
     */
    obtenerCfdiXmlPorCfdGuid(cfdGuid: string | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiXmlPorCfdGuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (cfdGuid === null)
            throw new Error("The parameter 'cfdGuid' cannot be null.");
        else if (cfdGuid !== undefined)
            url_ += "cfdGuid=" + encodeURIComponent("" + cfdGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiXmlPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiXmlPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiXmlPorCfdGuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener el XML de un Cfdi a través de su uuid
     * @param uuidCfdi (optional) Folio fiscal del Cfdi solicitado
     * @return XML codificado en base64
     */
    obtenerCfdiXmlPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiXmlPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiXmlPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiXmlPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiXmlPorUuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener la representación impresa de un Cfdi a través de su CfdGuid
     * @param cfdGuid (optional) Id del Cfdi en Sofi Conecta
     * @return XML codificado en base64
     */
    obtenerCfdiPdfPorCfdGuid(cfdGuid: string | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiPdfPorCfdGuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (cfdGuid === null)
            throw new Error("The parameter 'cfdGuid' cannot be null.");
        else if (cfdGuid !== undefined)
            url_ += "cfdGuid=" + encodeURIComponent("" + cfdGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiPdfPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiPdfPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiPdfPorCfdGuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener la representación impresa de un Cfdi a través de su uuid
     * @param uuidCfdi (optional) Folio fiscal del Cfdi solicitado
     * @return PDF de la representación impresa codificado en base64
     */
    obtenerCfdiPdfPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiPdfPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiPdfPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiPdfPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiPdfPorUuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener la representación impresa de un Cfdi a través de su CfdGuid
     * @param cfdGuid (optional) Id del Cfdi en Sofi Conecta
     * @return Imagen Jpeg del Cfdi codificada en base64
     */
    obtenerCfdiJpegPorCfdGuid(cfdGuid: string | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiJpegPorCfdGuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (cfdGuid === null)
            throw new Error("The parameter 'cfdGuid' cannot be null.");
        else if (cfdGuid !== undefined)
            url_ += "cfdGuid=" + encodeURIComponent("" + cfdGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiJpegPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiJpegPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiJpegPorCfdGuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve una vista previa de un Cfdi en formato jpeg por su uuid
     * @param uuidCfdi (optional) Folio fiscal del Cfdi solicitado
     * @return Imagen Jpeg del Cfdi codificada en base64
     */
    obtenerCfdiJpegPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdiJpegPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiJpegPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiJpegPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiJpegPorUuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite cancelar un Cfdi a través de su CfdGuid
     * @param cfdGuid (optional) Id del Cfdi en Sofi Conecta
     * @return Respuesta con datos acerca del proceso de cancelación iniciado
     */
    cancelarCfdiPorCfdGuid(cfdGuid: string | undefined, area: string): Observable<TimbrarServiceResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/CancelarCfdiPorCfdGuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (cfdGuid === null)
            throw new Error("The parameter 'cfdGuid' cannot be null.");
        else if (cfdGuid !== undefined)
            url_ += "cfdGuid=" + encodeURIComponent("" + cfdGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelarCfdiPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelarCfdiPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimbrarServiceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimbrarServiceResponse>;
        }));
    }

    protected processCancelarCfdiPorCfdGuid(response: HttpResponseBase): Observable<TimbrarServiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimbrarServiceResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite cancelar un Cfdi a través de su uuid
     * @param uuidCfdi (optional) Folio fiscal del Cfdi solicitado
     * @return Respuesta con datos acerca del proceso de cancelación iniciado
     */
    cancelarCfdiPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<TimbrarServiceResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/CancelarCfdiPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelarCfdiPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelarCfdiPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimbrarServiceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimbrarServiceResponse>;
        }));
    }

    protected processCancelarCfdiPorUuid(response: HttpResponseBase): Observable<TimbrarServiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimbrarServiceResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite enviar un Cfdi por su CfdGuid
     * @param peticion Id del Cfdi en Sofi Conecta que se desea enviar y listado de direcciones de correo electrónico a los que se desea enviar la factura
     */
    enviarCfdiCorreoPorCfdGuid(peticion: EnviarCfdiCorreoPorCfdGuidPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Facturacion/EnviarCfdiCorreoPorCfdGuid";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarCfdiCorreoPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarCfdiCorreoPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnviarCfdiCorreoPorCfdGuid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite enviar un Cfdi por su uuid
     * @param peticion Uuid del Cfdi que se desea enviar y listado de direcciones de correo electrónico a los que se desea enviar la factura
     */
    enviarCfdiCorreoPorUuid(peticion: EnviarCfdiCorreoPorUuidPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Facturacion/EnviarCfdiCorreoPorUuid";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarCfdiCorreoPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarCfdiCorreoPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnviarCfdiCorreoPorUuid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el estado de un Cfdi a través de su CfdGuid
     * @param cfdGuid (optional) Id del Cfdi en Sofi COnecta
     * @return Respuesta con el estado actual del Cfdi
     */
    obtenerEstadoCfdiPorCfdGuid(cfdGuid: string | undefined, area: string): Observable<ValidarCfdResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerEstadoCfdiPorCfdGuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (cfdGuid === null)
            throw new Error("The parameter 'cfdGuid' cannot be null.");
        else if (cfdGuid !== undefined)
            url_ += "cfdGuid=" + encodeURIComponent("" + cfdGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadoCfdiPorCfdGuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadoCfdiPorCfdGuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidarCfdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidarCfdResponse>;
        }));
    }

    protected processObtenerEstadoCfdiPorCfdGuid(response: HttpResponseBase): Observable<ValidarCfdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidarCfdResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el estado de un Cfdi a través del su uuid
     * @param uuidCfdi (optional) Folio fiscal del Cfdi
     * @return Respuesta con el estado actual del Cfdi
     */
    obtenerEstadoCfdiPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<ValidarCfdResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerEstadoCfdiPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadoCfdiPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadoCfdiPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidarCfdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidarCfdResponse>;
        }));
    }

    protected processObtenerEstadoCfdiPorUuid(response: HttpResponseBase): Observable<ValidarCfdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidarCfdResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene un listado con información de los Cfdis registrados para mostrarse en un grid de DevExtreme
     * @param options (optional) 
     */
    obtenerRaiterCfdisGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerRaiterCfdisGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerRaiterCfdisGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerRaiterCfdisGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerRaiterCfdisGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve la lista de UsosCfdi SAT
     */
    obtenerUsosCfdi(area: string): Observable<ObtenerUsosCfdiRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerUsosCfdi";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUsosCfdi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUsosCfdi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerUsosCfdiRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerUsosCfdiRespuesta[]>;
        }));
    }

    protected processObtenerUsosCfdi(response: HttpResponseBase): Observable<ObtenerUsosCfdiRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerUsosCfdiRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para timbrar una solicitud de viaje completada
     */
    timbrarSolicitudViaje(peticion: TimbrarSolicitudViajePeticion, area: string): Observable<TimbrarServiceResponse> {
        let url_ = this.baseUrl + "/{area}/Facturacion/TimbrarSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimbrarSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimbrarSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimbrarServiceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimbrarServiceResponse>;
        }));
    }

    protected processTimbrarSolicitudViaje(response: HttpResponseBase): Observable<TimbrarServiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimbrarServiceResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el uuid y cfdi guid de la factura al cliente de una solicitud si es que existe para evitar que se vuelva a generar
     * @param solicitudViajeId (optional) 
     */
    obtenerGuidFactura(solicitudViajeId: string | undefined, area: string): Observable<SolicitudViajeFacturaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerGuidFactura?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerGuidFactura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerGuidFactura(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeFacturaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeFacturaRespuesta>;
        }));
    }

    protected processObtenerGuidFactura(response: HttpResponseBase): Observable<SolicitudViajeFacturaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeFacturaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene las facturas realizadas por los usuarios del portal SofiCOneta en formato para un DataGrid DevExtreme
     * @param options (optional) 
     */
    obtenerCfdisGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerCfdisGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdisGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdisGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerCfdisGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuleve la lista de establecimientos registrados en Sofi COnecta
     */
    obtenerEstablecimientos(area: string): Observable<ObtenerEstableciminetosRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerEstablecimientos";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstablecimientos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstablecimientos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerEstableciminetosRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerEstableciminetosRespuesta[]>;
        }));
    }

    protected processObtenerEstablecimientos(response: HttpResponseBase): Observable<ObtenerEstableciminetosRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerEstableciminetosRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve las formas de pagos registradas en el archivo utilitario
     */
    obtenerFormasPago(area: string): Observable<SelectListUtil2[]> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerFormasPago";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerFormasPago(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerFormasPago(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil2[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil2[]>;
        }));
    }

    protected processObtenerFormasPago(response: HttpResponseBase): Observable<SelectListUtil2[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil2[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el listado de regimenes fiscales
     */
    obtenerRegimenesFiscales(area: string): Observable<SelectListUtil2[]> {
        let url_ = this.baseUrl + "/{area}/Facturacion/ObtenerRegimenesFiscales";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerRegimenesFiscales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerRegimenesFiscales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil2[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil2[]>;
        }));
    }

    protected processObtenerRegimenesFiscales(response: HttpResponseBase): Observable<SelectListUtil2[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil2[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FacturacionSWClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    timbrarViaje(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/FacturacionSW/timbrarViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimbrarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimbrarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processTimbrarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para timbrar una solicitud de viaje completada
     */
    timbrarSolicitudViaje(peticion: TimbrarSolicitudViajePeticion, area: string): Observable<TimbrarServiceResponse> {
        let url_ = this.baseUrl + "/{area}/FacturacionSW/TimbrarSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimbrarSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimbrarSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimbrarServiceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimbrarServiceResponse>;
        }));
    }

    protected processTimbrarSolicitudViaje(response: HttpResponseBase): Observable<TimbrarServiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimbrarServiceResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el XML de un CFDI por su UUID
     * @param uuidCfdi (optional) 
     */
    obtenerCfdiXmlPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/FacturacionSW/ObtenerCfdiXmlPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiXmlPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiXmlPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiXmlPorUuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el PDF de un CFDI por su UUID
     * @param uuidCfdi (optional) 
     */
    obtenerCfdiPdfPorUuid(uuidCfdi: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/FacturacionSW/ObtenerCfdiPdfPorUuid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (uuidCfdi !== undefined && uuidCfdi !== null)
            url_ += "uuidCfdi=" + encodeURIComponent("" + uuidCfdi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCfdiPdfPorUuid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCfdiPdfPorUuid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerCfdiPdfPorUuid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el identificador de una factura y su uuid
     * @param solicitudViajeId (optional) 
     */
    obtenerGuidFactura(solicitudViajeId: string | undefined, area: string): Observable<SolicitudViajeFacturaRespuesta> {
        let url_ = this.baseUrl + "/{area}/FacturacionSW/ObtenerGuidFactura?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerGuidFactura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerGuidFactura(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeFacturaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeFacturaRespuesta>;
        }));
    }

    protected processObtenerGuidFactura(response: HttpResponseBase): Observable<SolicitudViajeFacturaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeFacturaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FirebaseNotificacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite obtener las notificaciones de un usuario, anio y mes en especifico
     * @param anio (optional) 
     * @param mes (optional) 
     * @param idUsuario (optional) Identificador del usuario
     */
    obtenerNotificaciones(anio: number | undefined, mes: number | undefined, idUsuario: string | null | undefined, area: string): Observable<FirebaseNotificacionRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ObtenerNotificaciones?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (idUsuario !== undefined && idUsuario !== null)
            url_ += "idUsuario=" + encodeURIComponent("" + idUsuario) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerNotificaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerNotificaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FirebaseNotificacionRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FirebaseNotificacionRespuesta[]>;
        }));
    }

    protected processObtenerNotificaciones(response: HttpResponseBase): Observable<FirebaseNotificacionRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FirebaseNotificacionRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite a los usuarios eliminar una de sus notificaciones
     * @param id (optional) Identificador de la notificacipon
     */
    eliminarNotificacion(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/EliminarNotificacion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarNotificacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarNotificacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarNotificacion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve las ultima 5 notificaciones recibidas para el usuario logeado
     */
    obtenerUltimasNotificaciones(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ObtenerUltimasNotificaciones";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUltimasNotificaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUltimasNotificaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerUltimasNotificaciones(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los viajes registrados, con datos preparados para un DxDataGrid de DevExtreme
     * @param loadOptions (optional) 
     */
    obtenerMisNotificacionesGrid(loadOptions: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ObtenerMisNotificacionesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (loadOptions !== undefined && loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisNotificacionesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisNotificacionesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerMisNotificacionesGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite cambiar la bandera de leida a true
     * @param id (optional) Identificador de la notificación
     */
    actualizarNotificacionLeida(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ActualizarNotificacionLeida?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizarNotificacionLeida(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizarNotificacionLeida(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActualizarNotificacionLeida(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Recupera los diferentes tipos de notificaciones para proyectarlos en un combo
     */
    obtenerTiposNotificacion(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ObtenerTiposNotificacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposNotificacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposNotificacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerTiposNotificacion(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el numero de notificaciones no leidas
     */
    obtenerNotificacionesNoLeidas(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/FirebaseNotificacion/ObtenerNotificacionesNoLeidas";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerNotificacionesNoLeidas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerNotificacionesNoLeidas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerNotificacionesNoLeidas(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HomeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Ruta para obtener las cifras de clientes, choferes, pagos e ingresos de acuerdo a un mes y año específicos
     * @param mes (optional) Filtro por mes para realizar la búsqueda
     * @param anio (optional) Filtro por año para realizar la búsqueda
     */
    obtenerCifrasDashboard(mes: number | undefined, anio: number | undefined, area: string): Observable<DashboardRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Home/ObtenerCifrasDashboard?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCifrasDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCifrasDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardRespuesta[]>;
        }));
    }

    protected processObtenerCifrasDashboard(response: HttpResponseBase): Observable<DashboardRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DashboardRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el histórico de pagos de un mes seleccionado
     * @param mes (optional) 
     * @param anio (optional) 
     */
    obtenerNoPagosMes(mes: number | undefined, anio: number | undefined, area: string): Observable<NoPagosRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Home/ObtenerNoPagosMes?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerNoPagosMes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerNoPagosMes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoPagosRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoPagosRespuesta[]>;
        }));
    }

    protected processObtenerNoPagosMes(response: HttpResponseBase): Observable<NoPagosRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NoPagosRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el histórico de ingresos de pagos completados de un mes seleccionado
     * @param mes (optional) 
     * @param anio (optional) 
     */
    obtenerIngresosMensuales(mes: number | undefined, anio: number | undefined, area: string): Observable<IngresosMensualesRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Home/ObtenerIngresosMensuales?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerIngresosMensuales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerIngresosMensuales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngresosMensualesRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngresosMensualesRespuesta[]>;
        }));
    }

    protected processObtenerIngresosMensuales(response: HttpResponseBase): Observable<IngresosMensualesRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IngresosMensualesRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IncidenciaViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    registrarIncidenciaViaje(peticion: RegistrarIncidenciaViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/IncidenciaViaje/RegistrarIncidenciaViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarIncidenciaViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarIncidenciaViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarIncidenciaViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarIncidenciaViaje(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/IncidenciaViaje/EliminarIncidenciaViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarIncidenciaViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarIncidenciaViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarIncidenciaViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LugarInteresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerLugarInteresPorId(id: string | undefined, area: string): Observable<LugarInteresRespuesta> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/ObtenerLugarInteresPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerLugarInteresPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerLugarInteresPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LugarInteresRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LugarInteresRespuesta>;
        }));
    }

    protected processObtenerLugarInteresPorId(response: HttpResponseBase): Observable<LugarInteresRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LugarInteresRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerLugaresInteresPorUsuarioId(usuarioId: string | null | undefined, area: string): Observable<LugarInteresRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/ObtenerLugaresInteresPorUsuarioId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerLugaresInteresPorUsuarioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerLugaresInteresPorUsuarioId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LugarInteresRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LugarInteresRespuesta[]>;
        }));
    }

    protected processObtenerLugaresInteresPorUsuarioId(response: HttpResponseBase): Observable<LugarInteresRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LugarInteresRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarLugarInteres(peticion: RegistrarLugarInteresPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/RegistrarLugarInteres";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarLugarInteres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarLugarInteres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarLugarInteres(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editarLugarInteres(peticion: EditarLugarInteresPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/EditarLugarInteres";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarLugarInteres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarLugarInteres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditarLugarInteres(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarLugarInteres(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/EliminarLugarInteres?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarLugarInteres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarLugarInteres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarLugarInteres(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerLugaresInteresUsuarioWeb(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/ObtenerLugaresInteresUsuarioWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerLugaresInteresUsuarioWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerLugaresInteresUsuarioWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerLugaresInteresUsuarioWeb(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    guardarLugaresInteresWeb(arr: string[], area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/GuardarLugaresInteresWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(arr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuardarLugaresInteresWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuardarLugaresInteresWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGuardarLugaresInteresWeb(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerLugaresInteresUsuarioGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/ObtenerLugaresInteresUsuarioGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerLugaresInteresUsuarioGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerLugaresInteresUsuarioGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerLugaresInteresUsuarioGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarLugarInteresWeb(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/LugarInteres/EliminarLugarInteresWeb?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarLugarInteresWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarLugarInteresWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarLugarInteresWeb(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PagoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Metodo que devuelve los pagos realizados por un usuario especifico
     * @param options (optional) 
     */
    obtenerPagosGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Pago/ObtenerPagosGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPagosGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPagosGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerPagosGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesGeneralesPago(solicitudViajePagoId: string | undefined, area: string): Observable<ObtenerDetallesGeneralesPagoRespuesta> {
        let url_ = this.baseUrl + "/{area}/Pago/ObtenerDetallesGeneralesPago?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajePagoId === null)
            throw new Error("The parameter 'solicitudViajePagoId' cannot be null.");
        else if (solicitudViajePagoId !== undefined)
            url_ += "solicitudViajePagoId=" + encodeURIComponent("" + solicitudViajePagoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesGeneralesPago(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesGeneralesPago(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesGeneralesPagoRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesGeneralesPagoRespuesta>;
        }));
    }

    protected processObtenerDetallesGeneralesPago(response: HttpResponseBase): Observable<ObtenerDetallesGeneralesPagoRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesGeneralesPagoRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve los pagos realizados por un usuario especifico
     * @param options (optional) 
     */
    obtenerPagosRecibidosAdminGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Pago/ObtenerPagosRecibidosAdminGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPagosRecibidosAdminGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPagosRecibidosAdminGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerPagosRecibidosAdminGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuleve los pagos realizados por un usuario especifico
     * @param anio (optional) 
     * @param mes (optional) 
     */
    obtenerPagos(anio: number | undefined, mes: number | undefined, area: string): Observable<ObtenerPagosGridRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Pago/ObtenerPagos?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPagos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPagos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerPagosGridRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerPagosGridRespuesta[]>;
        }));
    }

    protected processObtenerPagos(response: HttpResponseBase): Observable<ObtenerPagosGridRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerPagosGridRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los ingresos realizados
     * @param options (optional) 
     */
    obtenerIngresosGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Pago/ObtenerIngresosGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerIngresosGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerIngresosGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerIngresosGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PagoOpenpayClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite pagar un servicio a través de Openpay utilizando tarjeta crédito/débito
     * @param peticion Datos para realizar el cargo/pago
     * @return Datos del estado de la operación del cargo con tarjeta
     */
    pagarConTarjeta(peticion: PagoTarjetaPeticion, area: string): Observable<PagoTarjetaRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/PagarConTarjeta";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagarConTarjeta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagarConTarjeta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagoTarjetaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagoTarjetaRespuesta>;
        }));
    }

    protected processPagarConTarjeta(response: HttpResponseBase): Observable<PagoTarjetaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PagoTarjetaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos para realizar el cargo correctamente", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse el cliente de Openpay que realiza el pago", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de crear el cargo con tarjeta", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para generar una referencia de pago para bancos en OPENPAY
     * @param solicitudViajeId (optional) 
     */
    generarReferenciaPagoBanco(solicitudViajeId: string | undefined, area: string): Observable<GenerarRefererenciaOpenpayRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/GenerarReferenciaPagoBanco?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerarReferenciaPagoBanco(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerarReferenciaPagoBanco(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
        }));
    }

    protected processGenerarReferenciaPagoBanco(response: HttpResponseBase): Observable<GenerarRefererenciaOpenpayRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerarRefererenciaOpenpayRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para generar una referencia para pago con tienda en OPENPAY
     * @param solicitudViajeId (optional) 
     */
    generarReferenciaTienda(solicitudViajeId: string | undefined, area: string): Observable<GenerarRefererenciaOpenpayRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/GenerarReferenciaTienda?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerarReferenciaTienda(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerarReferenciaTienda(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
        }));
    }

    protected processGenerarReferenciaTienda(response: HttpResponseBase): Observable<GenerarRefererenciaOpenpayRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerarRefererenciaOpenpayRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite volver a descargar una referencia para pago en banco
     * @param solicitudViajePagoOpenPayId (optional) 
     */
    descargarReferenciaBanco(solicitudViajePagoOpenPayId: string | undefined, area: string): Observable<GenerarRefererenciaOpenpayRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/DescargarReferenciaBanco?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajePagoOpenPayId === null)
            throw new Error("The parameter 'solicitudViajePagoOpenPayId' cannot be null.");
        else if (solicitudViajePagoOpenPayId !== undefined)
            url_ += "solicitudViajePagoOpenPayId=" + encodeURIComponent("" + solicitudViajePagoOpenPayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescargarReferenciaBanco(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescargarReferenciaBanco(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
        }));
    }

    protected processDescargarReferenciaBanco(response: HttpResponseBase): Observable<GenerarRefererenciaOpenpayRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerarRefererenciaOpenpayRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite volver a descargar una referencia para pago en tienda
     * @param solicitudViajePagoOpenPayId (optional) 
     */
    descargarReferenciaTienda(solicitudViajePagoOpenPayId: string | undefined, area: string): Observable<GenerarRefererenciaOpenpayRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/DescargarReferenciaTienda?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajePagoOpenPayId === null)
            throw new Error("The parameter 'solicitudViajePagoOpenPayId' cannot be null.");
        else if (solicitudViajePagoOpenPayId !== undefined)
            url_ += "solicitudViajePagoOpenPayId=" + encodeURIComponent("" + solicitudViajePagoOpenPayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescargarReferenciaTienda(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescargarReferenciaTienda(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerarRefererenciaOpenpayRespuesta>;
        }));
    }

    protected processDescargarReferenciaTienda(response: HttpResponseBase): Observable<GenerarRefererenciaOpenpayRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerarRefererenciaOpenpayRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Recepción de notificaciones openpay hooks
    https://www.openpay.mx/docs/webhooks.html
     */
    recepcionNotificaciones(peticion: OpenpayNotificacionPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/RecepcionNotificaciones";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecepcionNotificaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecepcionNotificaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRecepcionNotificaciones(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de pagos realizados con openpay para un Grid DevExtreme
     * @param options (optional) 
     */
    obtenerMisPagosRealizadosOpenpayGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/ObtenerMisPagosRealizadosOpenpayGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisPagosRealizadosOpenpayGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisPagosRealizadosOpenpayGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerMisPagosRealizadosOpenpayGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos de un pago openpay en especifico
     * @param solicitudViajePagoOpenpayId (optional) 
     */
    obtenerDetallesPagoOpenpay(solicitudViajePagoOpenpayId: string | undefined, area: string): Observable<ObtenerDetallesPagoOpenpayRespuesta> {
        let url_ = this.baseUrl + "/{area}/PagoOpenpay/ObtenerDetallesPagoOpenpay?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajePagoOpenpayId === null)
            throw new Error("The parameter 'solicitudViajePagoOpenpayId' cannot be null.");
        else if (solicitudViajePagoOpenpayId !== undefined)
            url_ += "solicitudViajePagoOpenpayId=" + encodeURIComponent("" + solicitudViajePagoOpenpayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesPagoOpenpay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesPagoOpenpay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesPagoOpenpayRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesPagoOpenpayRespuesta>;
        }));
    }

    protected processObtenerDetallesPagoOpenpay(response: HttpResponseBase): Observable<ObtenerDetallesPagoOpenpayRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesPagoOpenpayRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PostulacionViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerMisPostulacionesGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerMisPostulacionesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisPostulacionesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisPostulacionesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerMisPostulacionesGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerPostulacionesPorId(id: string | undefined, area: string): Observable<PostulacionViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionesPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionesPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionesPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeRespuesta>;
        }));
    }

    protected processObtenerPostulacionesPorId(response: HttpResponseBase): Observable<PostulacionViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerPostulacionesPorUsuarioId(usuarioId: string | null | undefined, area: string): Observable<PostulacionViajeUsuarioRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionesPorUsuarioId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionesPorUsuarioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionesPorUsuarioId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeUsuarioRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeUsuarioRespuesta[]>;
        }));
    }

    protected processObtenerPostulacionesPorUsuarioId(response: HttpResponseBase): Observable<PostulacionViajeUsuarioRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeUsuarioRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerPostulacionesPorUsuarioIdAnioMes(usuarioId: string | null | undefined, anio: number | undefined, mes: number | undefined, area: string): Observable<PostulacionViajeUsuarioRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionesPorUsuarioIdAnioMes?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionesPorUsuarioIdAnioMes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionesPorUsuarioIdAnioMes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeUsuarioRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeUsuarioRespuesta[]>;
        }));
    }

    protected processObtenerPostulacionesPorUsuarioIdAnioMes(response: HttpResponseBase): Observable<PostulacionViajeUsuarioRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeUsuarioRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarPostulacionViaje(peticion: RegistrarPostulacionViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/RegistrarPostulacionViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarPostulacionViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarPostulacionViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarPostulacionViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editarPostulacionViaje(peticion: EditarPostulacionViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/EditarPostulacionViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarPostulacionViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarPostulacionViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditarPostulacionViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finalizarPostulacionViaje(peticion: FinalizarPostulacionViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/FinalizarPostulacionViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalizarPostulacionViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalizarPostulacionViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processFinalizarPostulacionViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve las postulaciones que podrían interesarle a un transportista a través de su id
     * @param idTransportista (optional) Id del transportista
     */
    obtenerPostulacionesInteresTransportista(idTransportista: string | undefined, area: string): Observable<PostulacionViajeTransportistaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionesInteresTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idTransportista === null)
            throw new Error("The parameter 'idTransportista' cannot be null.");
        else if (idTransportista !== undefined)
            url_ += "idTransportista=" + encodeURIComponent("" + idTransportista) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionesInteresTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionesInteresTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeTransportistaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeTransportistaRespuesta[]>;
        }));
    }

    protected processObtenerPostulacionesInteresTransportista(response: HttpResponseBase): Observable<PostulacionViajeTransportistaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeTransportistaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerPostulacionesInteresTransportistaAnioMes(idTransportista: string | undefined, anio: number | undefined, mes: number | undefined, area: string): Observable<PostulacionViajeTransportistaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionesInteresTransportistaAnioMes?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idTransportista === null)
            throw new Error("The parameter 'idTransportista' cannot be null.");
        else if (idTransportista !== undefined)
            url_ += "idTransportista=" + encodeURIComponent("" + idTransportista) + "&";
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionesInteresTransportistaAnioMes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionesInteresTransportistaAnioMes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeTransportistaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeTransportistaRespuesta[]>;
        }));
    }

    protected processObtenerPostulacionesInteresTransportistaAnioMes(response: HttpResponseBase): Observable<PostulacionViajeTransportistaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeTransportistaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite a un transportista eliminar una postulación que ya no sea de su interes
     */
    descartarPostulacion(peticion: DescartarPostulacionPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/DescartarPostulacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescartarPostulacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescartarPostulacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDescartarPostulacion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    actualizarPostulacionTransportista(peticion: ActualizarPostulacionTransportistaPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ActualizarPostulacionTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizarPostulacionTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizarPostulacionTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processActualizarPostulacionTransportista(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve las postulacion de interes de un transportista
     */
    obtenerPostulacionInteresTransportista(peticion: PostulacionViajeTransportistaPeticion, area: string): Observable<PostulacionViajeTransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacionInteresTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacionInteresTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacionInteresTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeTransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeTransportistaRespuesta>;
        }));
    }

    protected processObtenerPostulacionInteresTransportista(response: HttpResponseBase): Observable<PostulacionViajeTransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeTransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve los detalles de una postulación en espeficico
     * @param postulacionViajeId (optional) 
     */
    obtenerPostulacion(postulacionViajeId: string | undefined, area: string): Observable<PostulacionViajeDetallesRespuesta> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerPostulacion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (postulacionViajeId === null)
            throw new Error("The parameter 'postulacionViajeId' cannot be null.");
        else if (postulacionViajeId !== undefined)
            url_ += "postulacionViajeId=" + encodeURIComponent("" + postulacionViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPostulacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPostulacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostulacionViajeDetallesRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostulacionViajeDetallesRespuesta>;
        }));
    }

    protected processObtenerPostulacion(response: HttpResponseBase): Observable<PostulacionViajeDetallesRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostulacionViajeDetallesRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve si un transportista ya ha registrado un viaje enlazado a una postulacion especifica
     * @param usuarioId (optional) 
     * @param postulacionViajeId (optional) 
     */
    existeViajeEnlazado(usuarioId: string | null | undefined, postulacionViajeId: string | undefined, area: string): Observable<string | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ExisteViajeEnlazado?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        if (postulacionViajeId === null)
            throw new Error("The parameter 'postulacionViajeId' cannot be null.");
        else if (postulacionViajeId !== undefined)
            url_ += "postulacionViajeId=" + encodeURIComponent("" + postulacionViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExisteViajeEnlazado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExisteViajeEnlazado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processExisteViajeEnlazado(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuleve los viajes relacionados a una postulación en especifico
     * @param options (optional) 
     * @param postulacionViajeId (optional) 
     */
    obtenerViajesRelacionados(options: DataSourceLoadOptions | null | undefined, postulacionViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerViajesRelacionados?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        if (postulacionViajeId === null)
            throw new Error("The parameter 'postulacionViajeId' cannot be null.");
        else if (postulacionViajeId !== undefined)
            url_ += "postulacionViajeId=" + encodeURIComponent("" + postulacionViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesRelacionados(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesRelacionados(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerViajesRelacionados(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los detalles de un viaje relacionado a una postulación
     * @param viajeId (optional) 
     * @param postulacionViajeId (optional) 
     */
    obtenerDetallesViajeRelacionado(viajeId: string | undefined, postulacionViajeId: string | undefined, area: string): Observable<ObtenerDetallesViajeRelacionadoRespuesta> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerDetallesViajeRelacionado?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (postulacionViajeId === null)
            throw new Error("The parameter 'postulacionViajeId' cannot be null.");
        else if (postulacionViajeId !== undefined)
            url_ += "postulacionViajeId=" + encodeURIComponent("" + postulacionViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesViajeRelacionado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesViajeRelacionado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesViajeRelacionadoRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesViajeRelacionadoRespuesta>;
        }));
    }

    protected processObtenerDetallesViajeRelacionado(response: HttpResponseBase): Observable<ObtenerDetallesViajeRelacionadoRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesViajeRelacionadoRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Relaciona un viaje existente a una postulación
     */
    relacionarViajeExistente(peticion: RelacionarViajeExistentePeticion, area: string): Observable<RelacionarViajeExistenteRespuesta> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/RelacionarViajeExistente";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRelacionarViajeExistente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRelacionarViajeExistente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelacionarViajeExistenteRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelacionarViajeExistenteRespuesta>;
        }));
    }

    protected processRelacionarViajeExistente(response: HttpResponseBase): Observable<RelacionarViajeExistenteRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RelacionarViajeExistenteRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerViajesSeleccionables(postulacionViajeId: string | undefined, area: string): Observable<ObtenerViajeSeleccionableRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/PostulacionViaje/ObtenerViajesSeleccionables?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (postulacionViajeId === null)
            throw new Error("The parameter 'postulacionViajeId' cannot be null.");
        else if (postulacionViajeId !== undefined)
            url_ += "postulacionViajeId=" + encodeURIComponent("" + postulacionViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesSeleccionables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesSeleccionables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajeSeleccionableRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajeSeleccionableRespuesta[]>;
        }));
    }

    protected processObtenerViajesSeleccionables(response: HttpResponseBase): Observable<ObtenerViajeSeleccionableRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajeSeleccionableRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RegimenFiscalSatClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Obtiene la información de los regimenes fiscales actuales SAT con sus usos CFDI para mostrar en un cambio
     */
    obtenerRegimenesFiscalesSatConUsosCfdi(area: string): Observable<ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/RegimenFiscalSat/ObtenerRegimenesFiscalesSatConUsosCfdi";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerRegimenesFiscalesSatConUsosCfdi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerRegimenesFiscalesSatConUsosCfdi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta[]>;
        }));
    }

    protected processObtenerRegimenesFiscalesSatConUsosCfdi(response: HttpResponseBase): Observable<ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de los regimenes fiscales sin los usos de CFDI
     */
    obtenerRegimenesFiscalesSat(area: string): Observable<ObtenerRegimenFiscalSatRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/RegimenFiscalSat/ObtenerRegimenesFiscalesSat";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerRegimenesFiscalesSat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerRegimenesFiscalesSat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerRegimenFiscalSatRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerRegimenFiscalSatRespuesta[]>;
        }));
    }

    protected processObtenerRegimenesFiscalesSat(response: HttpResponseBase): Observable<ObtenerRegimenFiscalSatRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerRegimenFiscalSatRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReporteUbicacionSolicitudViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    registrarReporte(peticion: RegistrarReporteUbicacionSolicitudViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/ReporteUbicacionSolicitudViaje/RegistrarReporte";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarReporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarReporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarReporte(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarReporte(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/ReporteUbicacionSolicitudViaje/EliminarReporte?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarReporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarReporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarReporte(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RolClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Método GET que devuelve los roles registrados
     * @return Listado de roles registrados en formato clave-valor
     */
    obtenerRoles(area: string): Observable<string[]> {
        let url_ = this.baseUrl + "/{area}/Rol/ObtenerRoles";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processObtenerRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SeguroClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Obtiene el listado de las mercancías posibles para contratar un seguro
     */
    obtenerMercanciasSeguroCombo(area: string): Observable<MercanciaSeguro[]> {
        let url_ = this.baseUrl + "/{area}/Seguro/ObtenerMercanciasSeguroCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMercanciasSeguroCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMercanciasSeguroCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MercanciaSeguro[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MercanciaSeguro[]>;
        }));
    }

    protected processObtenerMercanciasSeguroCombo(response: HttpResponseBase): Observable<MercanciaSeguro[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MercanciaSeguro[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite obtener la cotización de un seguro
     * @param peticion Datos de solicitud para obtener la cotización
     */
    obtenerCotizacion(peticion: SolicitarCotizacionPeticion, area: string): Observable<SolicitarCotizacionRespuesta> {
        let url_ = this.baseUrl + "/{area}/Seguro/ObtenerCotizacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCotizacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCotizacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitarCotizacionRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitarCotizacionRespuesta>;
        }));
    }

    protected processObtenerCotizacion(response: HttpResponseBase): Observable<SolicitarCotizacionRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitarCotizacionRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene las tarifas de seguros de contenedores
     */
    solicitarTarifaContenedores(area: string): Observable<SolicitarTarifaContenedorRespuesta> {
        let url_ = this.baseUrl + "/{area}/Seguro/SolicitarTarifaContenedores";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSolicitarTarifaContenedores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSolicitarTarifaContenedores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitarTarifaContenedorRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitarTarifaContenedorRespuesta>;
        }));
    }

    protected processSolicitarTarifaContenedores(response: HttpResponseBase): Observable<SolicitarTarifaContenedorRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitarTarifaContenedorRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Solicita un seguro de mercancía
     * @param peticion Datos para solicitar el seguro
     */
    solicitarSeguroMercancia(peticion: SolicitarSeguroMercanciaPeticion, area: string): Observable<SolicitarSeguroMercanciaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Seguro/SolicitarSeguroMercancia";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSolicitarSeguroMercancia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSolicitarSeguroMercancia(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitarSeguroMercanciaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitarSeguroMercanciaRespuesta>;
        }));
    }

    protected processSolicitarSeguroMercancia(response: HttpResponseBase): Observable<SolicitarSeguroMercanciaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitarSeguroMercanciaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Solicita un seguro para contenedor
     * @param peticion Datos para solicitar el seguro
     */
    solicitarSeguroContenedor(peticion: SolicitarSeguroContenedorPeticion, area: string): Observable<SolicitarSeguroContenedorRespuesta> {
        let url_ = this.baseUrl + "/{area}/Seguro/SolicitarSeguroContenedor";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSolicitarSeguroContenedor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSolicitarSeguroContenedor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitarSeguroContenedorRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitarSeguroContenedorRespuesta>;
        }));
    }

    protected processSolicitarSeguroContenedor(response: HttpResponseBase): Observable<SolicitarSeguroContenedorRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitarSeguroContenedorRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    descargarSeguroMercancia(id: string | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Seguro/DescargarSeguroMercancia?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescargarSeguroMercancia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescargarSeguroMercancia(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDescargarSeguroMercancia(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    descargarSeguroContenedor(id: string | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Seguro/DescargarSeguroContenedor?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescargarSeguroContenedor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescargarSeguroContenedor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDescargarSeguroContenedor(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosSolicitudViajeSeguro(solicitudViajeId: string | undefined, area: string): Observable<ObtenerDatosSolicitudViajeSeguroRespuesta> {
        let url_ = this.baseUrl + "/{area}/Seguro/ObtenerDatosSolicitudViajeSeguro?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosSolicitudViajeSeguro(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosSolicitudViajeSeguro(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDatosSolicitudViajeSeguroRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDatosSolicitudViajeSeguroRespuesta>;
        }));
    }

    protected processObtenerDatosSolicitudViajeSeguro(response: HttpResponseBase): Observable<ObtenerDatosSolicitudViajeSeguroRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDatosSolicitudViajeSeguroRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarSeguro(peticion: RegistrarSeguroPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Seguro/RegistrarSeguro";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarSeguro(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarSeguro(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarSeguro(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SepomexClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerEstados(area: string): Observable<string[]> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerEstados";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstados(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstados(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processObtenerEstados(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerEstadosConClave(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerEstadosConClave";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadosConClave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadosConClave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerEstadosConClave(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerMunicipiosPorEstado(estado: string | null | undefined, area: string): Observable<SepomexMunicipioRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerMunicipiosPorEstado?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (estado !== undefined && estado !== null)
            url_ += "estado=" + encodeURIComponent("" + estado) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMunicipiosPorEstado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMunicipiosPorEstado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SepomexMunicipioRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SepomexMunicipioRespuesta[]>;
        }));
    }

    protected processObtenerMunicipiosPorEstado(response: HttpResponseBase): Observable<SepomexMunicipioRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SepomexMunicipioRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSepomexIdPorEstadoMunicipio(estado: string | null | undefined, municipio: string | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerSepomexIdPorEstadoMunicipio?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (estado !== undefined && estado !== null)
            url_ += "estado=" + encodeURIComponent("" + estado) + "&";
        if (municipio !== undefined && municipio !== null)
            url_ += "municipio=" + encodeURIComponent("" + municipio) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSepomexIdPorEstadoMunicipio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSepomexIdPorEstadoMunicipio(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerSepomexIdPorEstadoMunicipio(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerMunicipiosTagBox(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerMunicipiosTagBox";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMunicipiosTagBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMunicipiosTagBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerMunicipiosTagBox(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerMunicipiosTagBoxFiltro(filtro: string | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerMunicipiosTagBoxFiltro?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (filtro !== undefined && filtro !== null)
            url_ += "filtro=" + encodeURIComponent("" + filtro) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMunicipiosTagBoxFiltro(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMunicipiosTagBoxFiltro(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerMunicipiosTagBoxFiltro(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerMunicipioPorCodigoPostal(codigoPostal: string | null | undefined, area: string): Observable<SepomexMunicipioRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Sepomex/ObtenerMunicipioPorCodigoPostal?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (codigoPostal !== undefined && codigoPostal !== null)
            url_ += "codigoPostal=" + encodeURIComponent("" + codigoPostal) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMunicipioPorCodigoPostal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMunicipioPorCodigoPostal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SepomexMunicipioRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SepomexMunicipioRespuesta[]>;
        }));
    }

    protected processObtenerMunicipioPorCodigoPostal(response: HttpResponseBase): Observable<SepomexMunicipioRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SepomexMunicipioRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SolicitudViajeArchivoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite anexar una factura en formato xml a una solicitud de viaje
     * @param peticion Archivo en base64
     */
    subirFacturaXml(peticion: RegistrarArchivoSolicitudViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirFacturaXml";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFacturaXml(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFacturaXml(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubirFacturaXml(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite anexar una factura en formato xml a una solicitud de viaje
     */
    subirFacturaPdf(peticion: RegistrarArchivoSolicitudViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirFacturaPdf";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFacturaPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFacturaPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubirFacturaPdf(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite anexar un codigo QR a una solicitud de viaje
     */
    subirCodigoQr(peticion: RegistrarArchivoSolicitudViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirCodigoQr";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirCodigoQr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirCodigoQr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubirCodigoQr(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite subir las imagenes anexas a una solictud de viaje desde la web
     * @param archivo (optional) 
     */
    subirImagenDetalleEnvioWeb(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirImagenDetalleEnvioWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenDetalleEnvioWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenDetalleEnvioWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirImagenDetalleEnvioWeb(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite subir una foto temporalmente de contactos que reciben o entregan mercancía en viajes
     * @param archivo (optional) 
     */
    subirImagenContacto(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirImagenContacto";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirImagenContacto(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirFacturaXmlTransportistaTemporal(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirFacturaXmlTransportistaTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFacturaXmlTransportistaTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFacturaXmlTransportistaTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirFacturaXmlTransportistaTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirFacturaPdfTransportistaTemporal(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirFacturaPdfTransportistaTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFacturaPdfTransportistaTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFacturaPdfTransportistaTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirFacturaPdfTransportistaTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirFacturasTransportistaWeb(peticion: SubirFacturasTransportistaPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirFacturasTransportistaWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFacturasTransportistaWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFacturasTransportistaWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirFacturasTransportistaWeb(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerFacturaXmlTransportista(solicitudViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/ObtenerFacturaXmlTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerFacturaXmlTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerFacturaXmlTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerFacturaXmlTransportista(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerFacturaPdfTransportista(solicitudViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/ObtenerFacturaPdfTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerFacturaPdfTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerFacturaPdfTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerFacturaPdfTransportista(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirCodigoQrTemporal(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/SubirCodigoQrTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirCodigoQrTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirCodigoQrTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirCodigoQrTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    descargarCodigoQr(solicitudViajeId: string | undefined, area: string): Observable<CodigoQrRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeArchivo/DescargarCodigoQr?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescargarCodigoQr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescargarCodigoQr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodigoQrRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodigoQrRespuesta>;
        }));
    }

    protected processDescargarCodigoQr(response: HttpResponseBase): Observable<CodigoQrRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CodigoQrRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SolicitudViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Obtiene la información de la solicitud de viaje por su id.
     * @param idSolicitudViaje (optional) 
     */
    obtenerSolicitudViajePorId(idSolicitudViaje: string | undefined, area: string): Observable<SolicitudViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSolicitudViajePorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idSolicitudViaje === null)
            throw new Error("The parameter 'idSolicitudViaje' cannot be null.");
        else if (idSolicitudViaje !== undefined)
            url_ += "idSolicitudViaje=" + encodeURIComponent("" + idSolicitudViaje) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSolicitudViajePorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSolicitudViajePorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeRespuesta>;
        }));
    }

    protected processObtenerSolicitudViajePorId(response: HttpResponseBase): Observable<SolicitudViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene las solicitudes de viaje de un usuario por su id
     * @param idUsuario (optional) 
     * @param fechaBusqueda (optional) 
     */
    obtenerSolicitudesViajePorUsuarioId(idUsuario: string | null | undefined, fechaBusqueda: string | undefined, area: string): Observable<SolicitudViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSolicitudesViajePorUsuarioId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUsuario !== undefined && idUsuario !== null)
            url_ += "idUsuario=" + encodeURIComponent("" + idUsuario) + "&";
        if (fechaBusqueda === null)
            throw new Error("The parameter 'fechaBusqueda' cannot be null.");
        else if (fechaBusqueda !== undefined)
            url_ += "fechaBusqueda=" + encodeURIComponent("" + fechaBusqueda) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSolicitudesViajePorUsuarioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSolicitudesViajePorUsuarioId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeRespuesta>;
        }));
    }

    protected processObtenerSolicitudesViajePorUsuarioId(response: HttpResponseBase): Observable<SolicitudViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene las solicitudes relacionadas a un viaje a través de su id
     * @param idViaje (optional) 
     */
    obtenerSolicitudesViajePorViajeId(idViaje: string | undefined, area: string): Observable<SolicitudViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSolicitudesViajePorViajeId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idViaje === null)
            throw new Error("The parameter 'idViaje' cannot be null.");
        else if (idViaje !== undefined)
            url_ += "idViaje=" + encodeURIComponent("" + idViaje) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSolicitudesViajePorViajeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSolicitudesViajePorViajeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeRespuesta>;
        }));
    }

    protected processObtenerSolicitudesViajePorViajeId(response: HttpResponseBase): Observable<SolicitudViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite registrar una solicitud de viaje desde la aplicación Raiter
     * @param peticion Datos para registrar la peticion
     */
    registrarSolicitudViaje(peticion: RegistrarSolicitudViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/RegistrarSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarSolicitudViaje(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite registrar una solicitud de viaje desde la Web de Raiter
     * @param peticion Datos para registrar la peticion
     */
    registrarSolicitudViajeWeb(peticion: RegistrarSolicitudViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/RegistrarSolicitudViajeWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarSolicitudViajeWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarSolicitudViajeWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarSolicitudViajeWeb(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite aceptar una solicitud de viaje, rechazando las demás asociadas al mismo viaje
     * @param peticion Datos de la solicitud a aceptar
     * @return La solicitud fue aceptada exitosamente
     */
    aceptarSolicitudViaje(peticion: ModificarEstadoSolicitudPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/AceptarSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAceptarSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAceptarSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAceptarSolicitudViaje(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la solicitud a aceptar", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando la solicitud fue previamente aceptada o rechazada, o bien existe otra solicitud relacionada al viaje que fue ya aceptada", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando las credenciales del usuario autenticado no coinciden con las del propietario del viaje", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Rechaza una solicitud de viaje
     * @param peticion Datos de la solicitud a rechazar
     * @return La solicitud fue rechazada exitosamente
     */
    rechazarSolicitudViaje(peticion: ModificarEstadoSolicitudPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/RechazarSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRechazarSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRechazarSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRechazarSolicitudViaje(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la solicitud a rechazar", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando la solicitud fue previamente aceptada o rechazada", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando las credenciales del usuario autenticado no coinciden con las del propietario del viaje", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite registrar los datos de contacto de una petición
     * @param peticion Información de los datos de contacto
     * @return Se registraron los datos de contacto exitosamente
     */
    registrarDatosContacto(peticion: RegistrarDatosContactoPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/RegistrarDatosContacto";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarDatosContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarDatosContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarDatosContacto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la solicitud a la que registrarle los datos de contacto", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite registrar los datos de contacto de una petición
     * @param peticion Información de los datos de contacto
     * @return Se registraron los datos de contacto exitosamente
     */
    registrarDatosContactoWeb(peticion: RegistrarDatosContactoPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/RegistrarDatosContactoWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarDatosContactoWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarDatosContactoWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarDatosContactoWeb(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la solicitud a la que registrarle los datos de contacto", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite editar los datos de contacto de una petición
     * @param peticion Nueva información de los datos de contacto
     * @return Se editaron los datos de contacto exitosamente
     */
    editarDatosContacto(peticion: RegistrarDatosContactoPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/EditarDatosContacto";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarDatosContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarDatosContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarDatosContacto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la solicitud a la que editarle los datos de contacto", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Establece como iniciada la ruta de una solicitud de viaje
     */
    iniciarRuta(peticion: IniciarSolicitudViajePeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/IniciarRuta";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIniciarRuta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIniciarRuta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIniciarRuta(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite dar por completada una solicitud de viaje al momento en el que se completa el viaje
     * @param peticion Datos para marcar como completada la petición
     */
    completarSolicitud(peticion: CompletarSolicitudPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/CompletarSolicitud";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletarSolicitud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletarSolicitud(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCompletarSolicitud(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite asignar una calificación a un viaje realizado asociándola a la solicitud que se llevó a cabo
     * @param peticion Datos de la evaluación del viaje
     */
    evaluarViaje(peticion: EvaluarViajePeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/EvaluarViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEvaluarViaje(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene datos auxiliares de una solicitud a mostrar en la pantalla de pago
     * @param id (optional) Id de la solicitud de viaje
     */
    obtenerDatosAuxiliaresPagoSolicitudViaje(id: string | undefined, area: string): Observable<DatosAuxiliaresPagoSolicitudViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosAuxiliaresPagoSolicitudViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosAuxiliaresPagoSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosAuxiliaresPagoSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatosAuxiliaresPagoSolicitudViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatosAuxiliaresPagoSolicitudViajeRespuesta>;
        }));
    }

    protected processObtenerDatosAuxiliaresPagoSolicitudViaje(response: HttpResponseBase): Observable<DatosAuxiliaresPagoSolicitudViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DatosAuxiliaresPagoSolicitudViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosAuxiliaresContacto(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosAuxiliaresContacto?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosAuxiliaresContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosAuxiliaresContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerDatosAuxiliaresContacto(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Muestra en un grid de DevExtreme las solicitudes de viaje hechas por el usuario autenticado
     * @param options (optional) 
     */
    obtenerMisSolicitudesGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerMisSolicitudesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisSolicitudesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisSolicitudesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerMisSolicitudesGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener las solicitudes de viajes, de un viaje en especifico
     * @param options (optional) 
     * @param viajeId (optional) 
     */
    obtenerSolicitudesViajeGrid(options: DataSourceLoadOptions | null | undefined, viajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSolicitudesViajeGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSolicitudesViajeGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSolicitudesViajeGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerSolicitudesViajeGrid(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerEstadosSolicitudViaje(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerEstadosSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadosSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadosSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerEstadosSolicitudViaje(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesSolicitudViajeNuevo(idSolicitud: string | undefined, area: string): Observable<SolicitudViajeRespuestaNuevo> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesSolicitudViajeNuevo?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idSolicitud === null)
            throw new Error("The parameter 'idSolicitud' cannot be null.");
        else if (idSolicitud !== undefined)
            url_ += "idSolicitud=" + encodeURIComponent("" + idSolicitud) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesSolicitudViajeNuevo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesSolicitudViajeNuevo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudViajeRespuestaNuevo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudViajeRespuestaNuevo>;
        }));
    }

    protected processObtenerDetallesSolicitudViajeNuevo(response: HttpResponseBase): Observable<SolicitudViajeRespuestaNuevo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudViajeRespuestaNuevo;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesPago(solicitudViajeId: string | undefined, area: string): Observable<any> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesPago?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesPago(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesPago(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processObtenerDetallesPago(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosContactoEdicion(idSolicitud: string | undefined, area: string): Observable<ObtenerDatosContactoEdicionRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosContactoEdicion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idSolicitud === null)
            throw new Error("The parameter 'idSolicitud' cannot be null.");
        else if (idSolicitud !== undefined)
            url_ += "idSolicitud=" + encodeURIComponent("" + idSolicitud) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosContactoEdicion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosContactoEdicion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDatosContactoEdicionRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDatosContactoEdicionRespuesta>;
        }));
    }

    protected processObtenerDatosContactoEdicion(response: HttpResponseBase): Observable<ObtenerDatosContactoEdicionRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDatosContactoEdicionRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosPrellenadoContacto(idSolicitud: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosPrellenadoContacto?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idSolicitud === null)
            throw new Error("The parameter 'idSolicitud' cannot be null.");
        else if (idSolicitud !== undefined)
            url_ += "idSolicitud=" + encodeURIComponent("" + idSolicitud) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosPrellenadoContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosPrellenadoContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerDatosPrellenadoContacto(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSucesosViaje(solicitudViajeId: string | undefined, area: string): Observable<SucesoViajeRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSucesosViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSucesosViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSucesosViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SucesoViajeRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SucesoViajeRespuesta[]>;
        }));
    }

    protected processObtenerSucesosViaje(response: HttpResponseBase): Observable<SucesoViajeRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SucesoViajeRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSolicitudViajeMapa(solicitudViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerSolicitudViajeMapa?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSolicitudViajeMapa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSolicitudViajeMapa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerSolicitudViajeMapa(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve los viajes de un usuario en especifico en un mes y año
     * @param idUsuario (optional) 
     * @param fechaBusqueda (optional) 
     * @param esChofer (optional) 
     */
    obtenerMisViajes(idUsuario: string | null | undefined, fechaBusqueda: string | undefined, esChofer: boolean | undefined, area: string): Observable<ObtenerMisViajesPendientesRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerMisViajes?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUsuario !== undefined && idUsuario !== null)
            url_ += "idUsuario=" + encodeURIComponent("" + idUsuario) + "&";
        if (fechaBusqueda === null)
            throw new Error("The parameter 'fechaBusqueda' cannot be null.");
        else if (fechaBusqueda !== undefined)
            url_ += "fechaBusqueda=" + encodeURIComponent("" + fechaBusqueda) + "&";
        if (esChofer === null)
            throw new Error("The parameter 'esChofer' cannot be null.");
        else if (esChofer !== undefined)
            url_ += "esChofer=" + encodeURIComponent("" + esChofer) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisViajes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisViajes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisViajesPendientesRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisViajesPendientesRespuesta[]>;
        }));
    }

    protected processObtenerMisViajes(response: HttpResponseBase): Observable<ObtenerMisViajesPendientesRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisViajesPendientesRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve los ultimos 5 viajes pendientes de un usuario en especifico
     * @param idUsuario (optional) 
     * @param esChofer (optional) 
     */
    obtenerMisViajesPendientes(idUsuario: string | null | undefined, esChofer: boolean | undefined, area: string): Observable<ObtenerMisViajesPendientesRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerMisViajesPendientes?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUsuario !== undefined && idUsuario !== null)
            url_ += "idUsuario=" + encodeURIComponent("" + idUsuario) + "&";
        if (esChofer === null)
            throw new Error("The parameter 'esChofer' cannot be null.");
        else if (esChofer !== undefined)
            url_ += "esChofer=" + encodeURIComponent("" + esChofer) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisViajesPendientes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisViajesPendientes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisViajesPendientesRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisViajesPendientesRespuesta[]>;
        }));
    }

    protected processObtenerMisViajesPendientes(response: HttpResponseBase): Observable<ObtenerMisViajesPendientesRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisViajesPendientesRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerEvaluacionViaje(solicitudViajeId: string | undefined, area: string): Observable<EvaluacionSolicitudViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerEvaluacionViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEvaluacionViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEvaluacionViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluacionSolicitudViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluacionSolicitudViajeRespuesta>;
        }));
    }

    protected processObtenerEvaluacionViaje(response: HttpResponseBase): Observable<EvaluacionSolicitudViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EvaluacionSolicitudViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosContacto(solicitudViajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosContacto?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosContacto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosContacto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerDatosContacto(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos del cliente de la solicitud para cuando en tiempo real se informe que el pagó se completó, se rellené la interfaz con esta información para ser vista por el transportista
     * @param solicitudViajeId (optional) 
     */
    obtenerDetallesCliente(solicitudViajeId: string | undefined, area: string): Observable<DetalleClienteRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesCliente?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesCliente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetalleClienteRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetalleClienteRespuesta>;
        }));
    }

    protected processObtenerDetallesCliente(response: HttpResponseBase): Observable<DetalleClienteRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DetalleClienteRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos del transportista que publicó el viaje, cuando se complete en tiempo real el pago de una solicitud, el cliente podrá ver los datos del transportista
     * @param solicitudViajeId (optional) 
     */
    obtenerDetallesTransportista(solicitudViajeId: string | undefined, area: string): Observable<DetalleTransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetalleTransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetalleTransportistaRespuesta>;
        }));
    }

    protected processObtenerDetallesTransportista(response: HttpResponseBase): Observable<DetalleTransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DetalleTransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tieneSolicitudViaje(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/TieneSolicitudViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTieneSolicitudViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTieneSolicitudViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processTieneSolicitudViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelarSolicitudViajeCliente(peticion: CancelarSolicitudViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/CancelarSolicitudViajeCliente";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelarSolicitudViajeCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelarSolicitudViajeCliente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCancelarSolicitudViajeCliente(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelarSolicitudViajeTransportista(peticion: CancelarSolicitudViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/CancelarSolicitudViajeTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelarSolicitudViajeTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelarSolicitudViajeTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCancelarSolicitudViajeTransportista(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesCancelacionSolicitudCliente(solicitudViajeId: string | undefined, area: string): Observable<ObtenerDetallesCancelacionSolicitudRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesCancelacionSolicitudCliente?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesCancelacionSolicitudCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesCancelacionSolicitudCliente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesCancelacionSolicitudRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesCancelacionSolicitudRespuesta>;
        }));
    }

    protected processObtenerDetallesCancelacionSolicitudCliente(response: HttpResponseBase): Observable<ObtenerDetallesCancelacionSolicitudRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesCancelacionSolicitudRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesCancelacionSolicitudTransportista(solicitudViajeId: string | undefined, area: string): Observable<ObtenerDetallesCancelacionSolicitudRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesCancelacionSolicitudTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesCancelacionSolicitudTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesCancelacionSolicitudTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesCancelacionSolicitudRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesCancelacionSolicitudRespuesta>;
        }));
    }

    protected processObtenerDetallesCancelacionSolicitudTransportista(response: HttpResponseBase): Observable<ObtenerDetallesCancelacionSolicitudRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesCancelacionSolicitudRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDetallesCancelacionSolicitud(solicitudViajeId: string | undefined, area: string): Observable<ObtenerDetallesCancelacionSolicitudPagoRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDetallesCancelacionSolicitud?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesCancelacionSolicitud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesCancelacionSolicitud(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesCancelacionSolicitudPagoRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesCancelacionSolicitudPagoRespuesta>;
        }));
    }

    protected processObtenerDetallesCancelacionSolicitud(response: HttpResponseBase): Observable<ObtenerDetallesCancelacionSolicitudPagoRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesCancelacionSolicitudPagoRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosSolicitudIniciada(solicitudViajeId: string | undefined, area: string): Observable<DetalleSolicitudIniciada> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosSolicitudIniciada?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosSolicitudIniciada(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosSolicitudIniciada(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetalleSolicitudIniciada>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetalleSolicitudIniciada>;
        }));
    }

    protected processObtenerDatosSolicitudIniciada(response: HttpResponseBase): Observable<DetalleSolicitudIniciada> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DetalleSolicitudIniciada;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerDatosSolicitudCompletada(solicitudViajeId: string | undefined, area: string): Observable<DatosSolicitudCompletadaRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViaje/ObtenerDatosSolicitudCompletada?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDatosSolicitudCompletada(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDatosSolicitudCompletada(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DatosSolicitudCompletadaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DatosSolicitudCompletadaRespuesta>;
        }));
    }

    protected processObtenerDatosSolicitudCompletada(response: HttpResponseBase): Observable<DatosSolicitudCompletadaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DatosSolicitudCompletadaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SolicitudViajeNegociacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerNegociaciones(solicitudViajeId: string | undefined, area: string): Observable<ObtenerSolititudViajeNegociacion[]> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/ObtenerNegociaciones?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerNegociaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerNegociaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerSolititudViajeNegociacion[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerSolititudViajeNegociacion[]>;
        }));
    }

    protected processObtenerNegociaciones(response: HttpResponseBase): Observable<ObtenerSolititudViajeNegociacion[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerSolititudViajeNegociacion[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarNegociacion(peticion: RegistrarSolicitudViajeNegociacionPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/RegistrarNegociacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarNegociacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarNegociacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarNegociacion(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    aceptarNegociacion(peticion: SolicitudViajeNegociacionPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/AceptarNegociacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAceptarNegociacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAceptarNegociacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAceptarNegociacion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    rechazarNegociacion(peticion: SolicitudViajeNegociacionPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/RechazarNegociacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRechazarNegociacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRechazarNegociacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRechazarNegociacion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelte las ultima 10 negociaciones de una solicitud de viaje
     * @param solicitudViajeId (optional) 
     */
    obtenerUltimasNegociaciones(solicitudViajeId: string | undefined, area: string): Observable<ObtenerNegociacionesRespuesta> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/ObtenerUltimasNegociaciones?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (solicitudViajeId === null)
            throw new Error("The parameter 'solicitudViajeId' cannot be null.");
        else if (solicitudViajeId !== undefined)
            url_ += "solicitudViajeId=" + encodeURIComponent("" + solicitudViajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUltimasNegociaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUltimasNegociaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerNegociacionesRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerNegociacionesRespuesta>;
        }));
    }

    protected processObtenerUltimasNegociaciones(response: HttpResponseBase): Observable<ObtenerNegociacionesRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerNegociacionesRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enviarNotificacionNegociacionTest(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SolicitudViajeNegociacion/EnviarNotificacionNegociacionTest";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarNotificacionNegociacionTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarNotificacionNegociacionTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEnviarNotificacionNegociacionTest(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SustanciaPeligrosaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerSustanciaPeligrosaPorId(sustanciaPeligrosaId: string | undefined, area: string): Observable<SustanciaPeligrosaRespuesta> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/ObtenerSustanciaPeligrosaPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (sustanciaPeligrosaId === null)
            throw new Error("The parameter 'sustanciaPeligrosaId' cannot be null.");
        else if (sustanciaPeligrosaId !== undefined)
            url_ += "sustanciaPeligrosaId=" + encodeURIComponent("" + sustanciaPeligrosaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSustanciaPeligrosaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSustanciaPeligrosaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SustanciaPeligrosaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SustanciaPeligrosaRespuesta>;
        }));
    }

    protected processObtenerSustanciaPeligrosaPorId(response: HttpResponseBase): Observable<SustanciaPeligrosaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SustanciaPeligrosaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSustanciasPeligrosasCombo(area: string): Observable<SustanciaPeligrosaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/ObtenerSustanciasPeligrosasCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSustanciasPeligrosasCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSustanciasPeligrosasCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SustanciaPeligrosaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SustanciaPeligrosaRespuesta[]>;
        }));
    }

    protected processObtenerSustanciasPeligrosasCombo(response: HttpResponseBase): Observable<SustanciaPeligrosaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SustanciaPeligrosaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSustanciasPeligrosasGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/ObtenerSustanciasPeligrosasGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSustanciasPeligrosasGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSustanciasPeligrosasGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerSustanciasPeligrosasGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarSustanciaPeligrosa(peticion: RegistrarSustanciaPeligrosaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/RegistrarSustanciaPeligrosa";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarSustanciaPeligrosa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarSustanciaPeligrosa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarSustanciaPeligrosa(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editarSustanciaPeligrosa(peticion: EditarSustanciaPeligrosaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/EditarSustanciaPeligrosa";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarSustanciaPeligrosa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarSustanciaPeligrosa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarSustanciaPeligrosa(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sustanciaPeligrosaId (optional) 
     * @return Eliminación correcta de la unidad de medida
     */
    eliminarSustanciaPeligrosa(sustanciaPeligrosaId: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/EliminarSustanciaPeligrosa?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (sustanciaPeligrosaId === null)
            throw new Error("The parameter 'sustanciaPeligrosaId' cannot be null.");
        else if (sustanciaPeligrosaId !== undefined)
            url_ += "sustanciaPeligrosaId=" + encodeURIComponent("" + sustanciaPeligrosaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarSustanciaPeligrosa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarSustanciaPeligrosa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarSustanciaPeligrosa(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerSustanciasPeligrosas(area: string): Observable<SustanciaPeligrosaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosa/ObtenerSustanciasPeligrosas";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerSustanciasPeligrosas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerSustanciasPeligrosas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SustanciaPeligrosaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SustanciaPeligrosaRespuesta[]>;
        }));
    }

    protected processObtenerSustanciasPeligrosas(response: HttpResponseBase): Observable<SustanciaPeligrosaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SustanciaPeligrosaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SustanciaPeligrosaImagenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    subirImagenSustanciaPeligrosaTemporal(imagen: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/SustanciaPeligrosaImagen/SubirImagenSustanciaPeligrosaTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imagen !== null && imagen !== undefined)
            content_.append("imagen", imagen.data, imagen.fileName ? imagen.fileName : "imagen");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenSustanciaPeligrosaTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenSustanciaPeligrosaTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirImagenSustanciaPeligrosaTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TipoUnidadTransporteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Obtene un listado con id y nombre de los tipos de unidades de transporte
     * @return Listado con id y nombre del tipo de unidad
     */
    obtenerTiposUnidadTransporteCombo(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposUnidadTransporteCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposUnidadTransporteCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposUnidadTransporteCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerTiposUnidadTransporteCombo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el tipo de unidad de transporte a través de un id
     * @param id (optional) Id del tipo de unidad que se busca
     * @return Información del tipo de unidad
     */
    obtenerTipoUnidadTransporte(id: string | undefined, area: string): Observable<TipoUnidadTransporteRespuesta> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTipoUnidadTransporte?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTipoUnidadTransporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTipoUnidadTransporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoUnidadTransporteRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoUnidadTransporteRespuesta>;
        }));
    }

    protected processObtenerTipoUnidadTransporte(response: HttpResponseBase): Observable<TipoUnidadTransporteRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TipoUnidadTransporteRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra el tipo de unidad con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de los tipos de unidad de transporte para un grid de DevExtreme
     * @param options (optional) 
     * @return Listado de Tipos de Unidad
     */
    obtenerTiposUnidadTransporteGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposUnidadTransporteGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposUnidadTransporteGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposUnidadTransporteGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerTiposUnidadTransporteGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Registra un tipo de unidad de transporte
     * @param peticion Petición con los datos del nuevo tipo de unidad
     */
    registrar(peticion: TipoUnidadTransporteRegistrarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/Registrar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrar(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan correctamente los datos para insertar el tipo de unidad", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando se introduce un usuario con nombre de un tipo de unidad que ya existe", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite editar un tipo de unidad de transporte existente
     * @param peticion Datos nuevos del tipo de unidad a editar
     * @return Confirmación de edición exitosa
     */
    editar(peticion: TipoUnidadTransporteEditarPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/Editar";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEditar(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan correctamente los datos para insertar el tipo de unidad", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando se introduce un nombre de tipo de unidad que ya est\u00e1 asociado con otro existente", status, _responseText, _headers, result409);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra el tipo de unidad con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite dar de baja un tipo de unidad de transporte existente
     * @param id (optional) Id del tipo de unidad de transporte a eliminar
     * @return Confirmación de eliminación exitosa
     */
    eliminar(id: string | undefined, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/Eliminar?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEliminar(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra el tipo de unidad con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los tipos de transporte (Caja seca, Porta Contenedores, Camion)
     */
    obtenerTiposTransporteCombo(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposTransporteCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposTransporteCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposTransporteCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerTiposTransporteCombo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que obtiene los tipos de transportes por categoria
     * @param categoria (optional) 
     */
    obtenerTiposTransportePorCategoria(categoria: TipoTransporte | undefined, area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposTransportePorCategoria?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (categoria === null)
            throw new Error("The parameter 'categoria' cannot be null.");
        else if (categoria !== undefined)
            url_ += "categoria=" + encodeURIComponent("" + categoria) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposTransportePorCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposTransportePorCategoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerTiposTransportePorCategoria(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerTiposTransportePorCategoriaCombo(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposTransportePorCategoriaCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposTransportePorCategoriaCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposTransportePorCategoriaCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerTiposTransportePorCategoriaCombo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerTiposTransporteBasicosCombo(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/TipoUnidadTransporte/ObtenerTiposTransporteBasicosCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTiposTransporteBasicosCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTiposTransporteBasicosCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerTiposTransporteBasicosCombo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransportistaArchivoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    subirLogotipo(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirLogotipo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirLogotipo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirLogotipo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirLogotipo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirBanner(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirBanner";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirBanner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirBanner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirBanner(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirImagenIneFrontal(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirImagenIneFrontal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenIneFrontal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenIneFrontal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirImagenIneFrontal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirImagenIneReverso(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirImagenIneReverso";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirImagenIneReverso(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirImagenIneReverso(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirImagenIneReverso(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirActaConstitutiva(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirActaConstitutiva";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirActaConstitutiva(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirActaConstitutiva(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirActaConstitutiva(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirComprobanteDomicilio(archivo: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaArchivo/SubirComprobanteDomicilio";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (archivo !== null && archivo !== undefined)
            content_.append("archivo", archivo.data, archivo.fileName ? archivo.fileName : "archivo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirComprobanteDomicilio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirComprobanteDomicilio(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirComprobanteDomicilio(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransportistaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Devuelve la información de un transportista
     * @param id (optional) 
     */
    obtenerTransportistaPorId(id: string | undefined, area: string): Observable<TransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerTransportistaPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTransportistaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTransportistaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportistaRespuesta>;
        }));
    }

    protected processObtenerTransportistaPorId(response: HttpResponseBase): Observable<TransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el listado de transportistas registrados junto con los choferes de cada uno para mostrarse en un grid de DevExtreme
     * @param options (optional) 
     */
    obtenerTransportistasGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerTransportistasGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTransportistasGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTransportistasGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerTransportistasGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ruta que indica si un transportista ya ha completado su registro o aún no
     * @param usuarioId (optional) 
     * @return or
     */
    verificarRegistroCompletado(usuarioId: string | null | undefined, area: string): Observable<string | null> {
        let url_ = this.baseUrl + "/{area}/Transportista/VerificarRegistroCompletado?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (usuarioId !== undefined && usuarioId !== null)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificarRegistroCompletado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificarRegistroCompletado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processVerificarRegistroCompletado(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método antiguo para dar de alta a transportistas
     */
    registrarTransportista(peticion: RegistrarTransportistaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/RegistrarTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarTransportista(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite que los usuarios se den de alta como transportistas, enviando sus correspondientes datos. Método actual para registrar transportistas
     */
    registrarTransportistaWeb(peticion: RegistrarTransportistaWebPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/RegistrarTransportistaWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarTransportistaWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarTransportistaWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarTransportistaWeb(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método actual para dar de alta transportistas desde la app Raiter
     */
    registrarTransportistaApp(peticion: RegistrarTransportistaAppPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/RegistrarTransportistaApp";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarTransportistaApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarTransportistaApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarTransportistaApp(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite a los usuarios actualizar sus datos de transportista en caso de ser necesario
     */
    actualizarTransportista(peticion: RegistrarTransportistaWebPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/ActualizarTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizarTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizarTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processActualizarTransportista(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método antiguo para editar transporistas
     */
    editarTransportista(peticion: EditarTransportistaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/EditarTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarTransportista(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarTransportista(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Transportista/EliminarTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarTransportista(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos de transportista del usuario autenticado si aplica
     */
    obtenerMisDatosTransportista(area: string): Observable<ObtenerMisDatosTransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerMisDatosTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisDatosTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisDatosTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
        }));
    }

    protected processObtenerMisDatosTransportista(response: HttpResponseBase): Observable<ObtenerMisDatosTransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisDatosTransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos de un usuario transportista a través de su id para su visualización y verificación por parte de administrativos
     * @param id (optional) 
     */
    obtenerDetallesTransportista(id: string | undefined, area: string): Observable<ObtenerMisDatosTransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerDetallesTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
        }));
    }

    protected processObtenerDetallesTransportista(response: HttpResponseBase): Observable<ObtenerMisDatosTransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisDatosTransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos de un usuario transportista a través de su id para su visualización y verificación por parte de administrativos
     * @param transportistaId (optional) 
     */
    obtenerTransportistaAdmin(transportistaId: string | undefined, area: string): Observable<ObtenerMisDatosTransportistaRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerTransportistaAdmin?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (transportistaId === null)
            throw new Error("The parameter 'transportistaId' cannot be null.");
        else if (transportistaId !== undefined)
            url_ += "transportistaId=" + encodeURIComponent("" + transportistaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTransportistaAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTransportistaAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisDatosTransportistaRespuesta>;
        }));
    }

    protected processObtenerTransportistaAdmin(response: HttpResponseBase): Observable<ObtenerMisDatosTransportistaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisDatosTransportistaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los posibles estados de verificación de transportista en la plataforma Raiter. En proceso, Rechazado, Aprobado
     */
    obtenerEstadosVerificacionTransportista(area: string): Observable<ObtenerEstadosVerificacionTransportistaCombo[]> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerEstadosVerificacionTransportista";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadosVerificacionTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadosVerificacionTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerEstadosVerificacionTransportistaCombo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerEstadosVerificacionTransportistaCombo[]>;
        }));
    }

    protected processObtenerEstadosVerificacionTransportista(response: HttpResponseBase): Observable<ObtenerEstadosVerificacionTransportistaCombo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerEstadosVerificacionTransportistaCombo[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite actualizar el estado de verificación de un usuario que se postula como transporista despues de ver los datos que éste subio a la plataforma
     */
    actualizarEstadoVerificacion(peticion: ActualizarEstadoVerificacionTransportistaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Transportista/ActualizarEstadoVerificacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizarEstadoVerificacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizarEstadoVerificacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processActualizarEstadoVerificacion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los datos de verificación de transportista más recientes del usuario autenticado, usado en el panel "Mis Datos" (de transportista) para recargar y obtener la actualización de estado de verificación más reciente
     */
    recargarMiEstadoVerificacion(area: string): Observable<EstadoVerificacionRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/RecargarMiEstadoVerificacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecargarMiEstadoVerificacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecargarMiEstadoVerificacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoVerificacionRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoVerificacionRespuesta>;
        }));
    }

    protected processRecargarMiEstadoVerificacion(response: HttpResponseBase): Observable<EstadoVerificacionRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EstadoVerificacionRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de estado de verificación de determinado transportista
     * @param id (optional) 
     */
    obtenerEstadoVerificacionTransportista(id: string | undefined, area: string): Observable<EstadoVerificacionRespuesta> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerEstadoVerificacionTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadoVerificacionTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadoVerificacionTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoVerificacionRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoVerificacionRespuesta>;
        }));
    }

    protected processObtenerEstadoVerificacionTransportista(response: HttpResponseBase): Observable<EstadoVerificacionRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EstadoVerificacionRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los comentarios de evaluaciones hechos a un transportista
     * @param transportistaId (optional) 
     * @param pagina (optional) 
     */
    obtenerComentariosTransportista(transportistaId: string | undefined, pagina: number | undefined, area: string): Observable<ObtenerComentarioTransportistaRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerComentariosTransportista?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (transportistaId === null)
            throw new Error("The parameter 'transportistaId' cannot be null.");
        else if (transportistaId !== undefined)
            url_ += "transportistaId=" + encodeURIComponent("" + transportistaId) + "&";
        if (pagina === null)
            throw new Error("The parameter 'pagina' cannot be null.");
        else if (pagina !== undefined)
            url_ += "pagina=" + encodeURIComponent("" + pagina) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerComentariosTransportista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerComentariosTransportista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerComentarioTransportistaRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerComentarioTransportistaRespuesta[]>;
        }));
    }

    protected processObtenerComentariosTransportista(response: HttpResponseBase): Observable<ObtenerComentarioTransportistaRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerComentarioTransportistaRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el combo de transportistas disponibles en Raiter
     * @param options (optional) 
     */
    obtenerTransportistasCombo(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Transportista/ObtenerTransportistasCombo?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTransportistasCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTransportistasCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerTransportistasCombo(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransportistaImagenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    subirFotoPerfilTemporal(imagen: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaImagen/SubirFotoPerfilTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imagen !== null && imagen !== undefined)
            content_.append("imagen", imagen.data, imagen.fileName ? imagen.fileName : "imagen");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFotoPerfilTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFotoPerfilTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirFotoPerfilTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    subirFotoBannerTemporal(imagen: FileParameter | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/TransportistaImagen/SubirFotoBannerTemporal";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imagen !== null && imagen !== undefined)
            content_.append("imagen", imagen.data, imagen.fileName ? imagen.fileName : "imagen");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFotoBannerTemporal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFotoBannerTemporal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSubirFotoBannerTemporal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransportistaVerificacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Devuelve el listado de verificacion para un transportista en espeficico para un grid DevExpress
     * @param options (optional) 
     * @param transportistaId (optional) 
     */
    obtenerTransportistaVerificacionesGrid(options: DataSourceLoadOptions | null | undefined, transportistaId: string | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/TransportistaVerificacion/ObtenerTransportistaVerificacionesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        if (transportistaId === null)
            throw new Error("The parameter 'transportistaId' cannot be null.");
        else if (transportistaId !== undefined)
            url_ += "transportistaId=" + encodeURIComponent("" + transportistaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTransportistaVerificacionesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTransportistaVerificacionesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerTransportistaVerificacionesGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UnidadMedidaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    obtenerUnidadMedidaPorId(idUnidad: string | undefined, area: string): Observable<UnidadMedidaRespuesta> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/ObtenerUnidadMedidaPorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUnidad === null)
            throw new Error("The parameter 'idUnidad' cannot be null.");
        else if (idUnidad !== undefined)
            url_ += "idUnidad=" + encodeURIComponent("" + idUnidad) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadMedidaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadMedidaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnidadMedidaRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnidadMedidaRespuesta>;
        }));
    }

    protected processObtenerUnidadMedidaPorId(response: HttpResponseBase): Observable<UnidadMedidaRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnidadMedidaRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerUnidadesMedidaGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/ObtenerUnidadesMedidaGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesMedidaGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesMedidaGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerUnidadesMedidaGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrarUnidadMedida(peticion: RegistrarUnidadMedidaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/RegistrarUnidadMedida";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarUnidadMedida(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarUnidadMedida(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarUnidadMedida(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editarUnidadMedida(peticion: EditarUnidadMedidaPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/EditarUnidadMedida";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarUnidadMedida(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarUnidadMedida(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarUnidadMedida(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param idUnidad (optional) 
     * @return Eliminación correcta de la unidad de medida
     */
    eliminarUnidadMedida(idUnidad: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/EliminarUnidadMedida?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (idUnidad === null)
            throw new Error("The parameter 'idUnidad' cannot be null.");
        else if (idUnidad !== undefined)
            url_ += "idUnidad=" + encodeURIComponent("" + idUnidad) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarUnidadMedida(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarUnidadMedida(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarUnidadMedida(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerUnidadMedidaNombreAbr(nombreabr: string | null | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/ObtenerUnidadMedidaNombreAbr?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (nombreabr !== undefined && nombreabr !== null)
            url_ += "nombreabr=" + encodeURIComponent("" + nombreabr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadMedidaNombreAbr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadMedidaNombreAbr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerUnidadMedidaNombreAbr(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerUnidadesMedida(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/ObtenerUnidadesMedida";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesMedida(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesMedida(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerUnidadesMedida(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerUnidadesMedidaComboTipo(tipoUnidadMedida: TipoUnidadMedida | null | undefined, area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/UnidadMedida/ObtenerUnidadesMedidaComboTipo?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (tipoUnidadMedida !== undefined && tipoUnidadMedida !== null)
            url_ += "tipoUnidadMedida=" + encodeURIComponent("" + tipoUnidadMedida) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesMedidaComboTipo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesMedidaComboTipo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerUnidadesMedidaComboTipo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UnidadTransporteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Lista las unidades de transporte registradas para mostrarse en un grid de DevExtreme
     * @param options (optional) 
     * @return Listado de unidades de transporte para el grid de DevExtreme
     */
    obtenerUnidadesTransporteGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/ObtenerUnidadesTransporteGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesTransporteGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesTransporteGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerUnidadesTransporteGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando existe un error al tratar de cargar la lista de unidades de transporte", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la información de una unidad de transporte a través de su identificador de base de datos
     * @param id (optional) Identificador de la unidad de transporte buscada
     * @return Información de la unidad de transporte que se busca
     */
    obtenerUnidadTransportePorId(id: string | undefined, area: string): Observable<UnidadTransporteRespuesta> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/ObtenerUnidadTransportePorId?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadTransportePorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadTransportePorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnidadTransporteRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnidadTransporteRespuesta>;
        }));
    }

    protected processObtenerUnidadTransportePorId(response: HttpResponseBase): Observable<UnidadTransporteRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnidadTransporteRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para ver la informaci\u00f3n de la unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si se env\u00eda un id inv\u00e1lido", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra la unidad de transporte con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("De darse un error al recuperar la informaci\u00f3n de la unidad de transporte", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite registrar una unidad de transporte
     * @param peticion Datos de la nueva unidad de transporte
     * @return Unidad de transporte del chofer registrado
     */
    registrarUnidadTransporte(peticion: UnidadTransporteRegistrarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/RegistrarUnidadTransporte";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarUnidadTransporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarUnidadTransporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarUnidadTransporte(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir una unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de registro correctamente", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de registrar la unidad de transporte", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite modificar la información de una unidad de transporte
     * @param peticion Datos nuevos de la unidad de transporte que se edita
     * @return Id de la unidad de transporte editado
     */
    editarUnidadTransporte(peticion: UnidadTransporteEditarPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/EditarUnidadTransporte";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarUnidadTransporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarUnidadTransporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEditarUnidadTransporte(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para editar una unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan los campos de edici\u00f3n correctamente o hay una petici\u00f3n vac\u00eda", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la unidad de transporte que se va a editar", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de editar la unidad de transporte", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite dar de baja una unidad de transporte
     * @param id (optional) Identificador de la unidad de transporte a eliminar
     * @return Cuando la unidad de transporte ha sido eliminado correctamente
     */
    eliminarUnidadTransporte(id: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/EliminarUnidadTransporte?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarUnidadTransporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarUnidadTransporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEliminarUnidadTransporte(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para eliminar una unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Si no se env\u00eda el id de la unidad de transporte a eliminar", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no encontrarse la unidad de transporte que se va a eliminar con el id prporcionador", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al tratar de eliminar la unidad de transporte", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener unidades de transporte registradas a un usuario
     * @param id (optional) 
     * @return Listado de unidades de transporte para el usuario especificado
     */
    obtenerUnidadesTransportePorUsuario(id: string | null | undefined, area: string): Observable<ObtenerUnidadesTransportePorUsuarioRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/ObtenerUnidadesTransportePorUsuario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesTransportePorUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesTransportePorUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerUnidadesTransportePorUsuarioRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerUnidadesTransportePorUsuarioRespuesta[]>;
        }));
    }

    protected processObtenerUnidadesTransportePorUsuario(response: HttpResponseBase): Observable<ObtenerUnidadesTransportePorUsuarioRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerUnidadesTransportePorUsuarioRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para eliminar una unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerUnidadesTransporteCombo(area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporte/ObtenerUnidadesTransporteCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUnidadesTransporteCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUnidadesTransporteCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerUnidadesTransporteCombo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UnidadTransporteImagenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Permite subir la primera foto de una unidad de transporte
     * @param fotouno (optional) Archivo de la imagen. Formatos permitidos: jpg, png, jpeg, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirFotoUnoUnidad(fotouno: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporteImagen/SubirFotoUnoUnidad";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fotouno !== null && fotouno !== undefined)
            content_.append("fotouno", fotouno.data, fotouno.fileName ? fotouno.fileName : "fotouno");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFotoUnoUnidad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFotoUnoUnidad(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirFotoUnoUnidad(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite subir la segunda foto de una unidad de transporte
     * @param fotodos (optional) Archivo de la imagen. Formatos permitods: jpg, png, jpep, bmp
     * @return Ruta virtual y nombre de la imagen subida exitosamente
     */
    subirFotoDosUnidad(fotodos: FileParameter | null | undefined, area: string): Observable<ChoferImagenRespuesta> {
        let url_ = this.baseUrl + "/{area}/UnidadTransporteImagen/SubirFotoDosUnidad";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fotodos !== null && fotodos !== undefined)
            content_.append("fotodos", fotodos.data, fotodos.fileName ? fotodos.fileName : "fotodos");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubirFotoDosUnidad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubirFotoDosUnidad(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChoferImagenRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChoferImagenRespuesta>;
        }));
    }

    protected processSubirFotoDosUnidad(response: HttpResponseBase): Observable<ChoferImagenRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChoferImagenRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos para a\u00f1adir im\u00e1genes de unidad de transporte", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al no enviarse correctamente la imagen o en un formato no admitido", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Al darse un error al cargar la imagen", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UsuarioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    /**
     * Método POST para el registro de un usuario
     * @param request Entidad que contiene la información necesaria para el registro del usuario
     * @return Id del usuario registrado
     */
    registrarUsuario(request: RegistroUsuarioPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Usuario/RegistrarUsuario";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarUsuario(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan correctamente los datos para insertar el usuario", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando se introduce un usuario con nombre o e-mail de otro usuario que ya existe", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método POST para el registro de un usuario
     * @param request Entidad que contiene la información necesaria para el registro del usuario
     * @return Id del usuario registrado
     */
    registrarUsuarioWeb(request: RegistroUsuarioWebPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Usuario/RegistrarUsuarioWeb";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarUsuarioWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarUsuarioWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegistrarUsuarioWeb(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan correctamente los datos para insertar el usuario", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando se introduce un usuario con nombre o e-mail de otro usuario que ya existe", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método POST para que un usuario registrado inicie sesión a través de cookies, en un navegador
     * @param request Contiene el e-mail y contraseña del usuario que intenta iniciar sesión
     * @return Bandera que indica si el inicio de sesión fue exitoso o no
     */
    iniciarSesion(request: InicioSesionPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/Usuario/IniciarSesion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIniciarSesion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIniciarSesion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIniciarSesion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00eda correctamente el e-mail o la contrase\u00f1a", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método para cerrar sesión en un navegador
     * @return Código de HTTP que indica que el cierre de sesión fue exitoso
     */
    cerrarSesion(area: string): Observable<HttpStatusCode> {
        let url_ = this.baseUrl + "/{area}/Usuario/CerrarSesion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCerrarSesion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCerrarSesion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HttpStatusCode>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HttpStatusCode>;
        }));
    }

    protected processCerrarSesion(response: HttpResponseBase): Observable<HttpStatusCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpStatusCode;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve todos los usuarios registrados para insertar en un DxGridControl de DevExtreme
     * @param loadOptions (optional) 
     * @return Listado de usuarios
     */
    obtenerUsuarios(loadOptions: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerUsuarios?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (loadOptions !== undefined && loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUsuarios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUsuarios(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerUsuarios(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene un token JWT proporcionando e-mail y contraseña válidos para poder utilizar los servicios proporcionados por las APIS de Pagos Raiter fuera de un navegador
     * @param request Incluye el e-mail y la contraseña del usuario que intenta autenticarse y obtener un token
     * @return Token JWT
     */
    obtenerToken(request: InicioSesionPeticion, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerToken";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00eda correctamente el e-mail o la contrase\u00f1a", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los detalles de un usuario a través su id, es útil por ejemplo para el formulario de edición 
    de usuarios
     * @param id (optional) Id del usuario
     * @return Detalles del usuario, a excepción de su contraseña
     */
    obtenerUsuario(id: string | null | undefined, area: string): Observable<ObtenerUsuariosRespuesta> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerUsuario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerUsuariosRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerUsuariosRespuesta>;
        }));
    }

    protected processObtenerUsuario(response: HttpResponseBase): Observable<ObtenerUsuariosRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerUsuariosRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra el usuario con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite editar los datos de un usuario existente
     * @param peticion Datos nuevos para el usuario
     * @return Confirmación de que la edición se realizó con exitosamente
     */
    editarUsuario(peticion: EditarUsuarioPeticion, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/Usuario/EditarUsuario";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEditarUsuario(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando no se env\u00edan correctamente los datos para insertar el usuario", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Cuando se introduce un usuario con nombre o e-mail de otro usuario que ya existe", status, _responseText, _headers, result409);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("Sucede cuando no se encuentra el usuario con el id que se proporcion\u00f3", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RaiterException;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene todos los usuarios registrados para el SelectBox.
     */
    obtenerUsuariosCombo(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerUsuariosCombo";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerUsuariosCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerUsuariosCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerUsuariosCombo(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener el token firebase registrado del usuario
     * @param id (optional) 
     * @return Token firebase
     */
    obtenerTokenFirebase(id: string | null | undefined, area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerTokenFirebase?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTokenFirebase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTokenFirebase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerTokenFirebase(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reenviarConfirmacionEmail(email: string | null | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Usuario/ReenviarConfirmacionEmail?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReenviarConfirmacionEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReenviarConfirmacionEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReenviarConfirmacionEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el teléfono del usuario que se encuentra autenticado
     */
    obtenerTelefonoUsuarioAutenticado(area: string): Observable<string> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerTelefonoUsuarioAutenticado";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTelefonoUsuarioAutenticado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTelefonoUsuarioAutenticado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processObtenerTelefonoUsuarioAutenticado(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite inhabilitar la cuenta de un usuario
     * @param id (optional) Id del usuario a desactivar
     */
    desactivarUsuario(id: string | null | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Usuario/DesactivarUsuario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDesactivarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDesactivarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDesactivarUsuario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite marcar como activo el estado de un usuario
     * @param id (optional) Id del usuario a activar
     */
    reactivarUsuario(id: string | null | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Usuario/ReactivarUsuario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReactivarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReactivarUsuario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerPropietarios(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerPropietarios";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerPropietarios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerPropietarios(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerPropietarios(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enviarTokenRecuperacionContrasenia(email: string | null | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Usuario/EnviarTokenRecuperacionContrasenia?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviarTokenRecuperacionContrasenia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviarTokenRecuperacionContrasenia(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnviarTokenRecuperacionContrasenia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    restablecerContraseniaConfirmacion(peticion: RestablecerContraseniaPeticion, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Usuario/RestablecerContraseniaConfirmacion";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestablecerContraseniaConfirmacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestablecerContraseniaConfirmacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestablecerContraseniaConfirmacion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuelve los datos basicos del usuario logeado
     */
    obtenerMisDatos(area: string): Observable<ObtenerMisDatosRespuesta> {
        let url_ = this.baseUrl + "/{area}/Usuario/ObtenerMisDatos";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisDatos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisDatos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerMisDatosRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerMisDatosRespuesta>;
        }));
    }

    protected processObtenerMisDatos(response: HttpResponseBase): Observable<ObtenerMisDatosRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerMisDatosRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para editar los datos basicos de un usuario en especifico.
     */
    editarMisDatos(peticion: ObtenerMisDatosRespuesta, area: string): Observable<boolean> {
        let url_ = this.baseUrl + "/{area}/Usuario/EditarMisDatos";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarMisDatos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarMisDatos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEditarMisDatos(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para cambiar la constraseña de usuario logeado
     */
    cambiarMiPassword(peticion: CambiarPasswordPeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Usuario/CambiarMiPassword";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCambiarMiPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCambiarMiPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCambiarMiPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmarEmail(token: string | null | undefined, email: string | null | undefined, area: string): Observable<ConfirmarEmailRespuesta> {
        let url_ = this.baseUrl + "/{area}/Usuario/ConfirmarEmail?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmarEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmarEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfirmarEmailRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfirmarEmailRespuesta>;
        }));
    }

    protected processConfirmarEmail(response: HttpResponseBase): Observable<ConfirmarEmailRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConfirmarEmailRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://localhost:57909";
    }

    registrarViaje(peticion: RegistrarViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/RegistrarViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegistrarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    obtenerViajeEdicion(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajeEdicion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajeEdicion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajeEdicion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processObtenerViajeEdicion(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editarViaje(peticion: EditarViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/EditarViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eliminarViaje(id: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/EliminarViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEliminarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los viajes registrados, con datos preparados para un DxDataGrid de DevExtreme
     * @param loadOptions (optional) 
     */
    obtenerViajesGrid(loadOptions: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (loadOptions !== undefined && loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerViajesGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los viajes que estan en proceso de negociacion, con datos preparados para un DxDataGrid de DevExtreme
     * @param loadOptions (optional) 
     */
    obtenerMisViajesGrid(loadOptions: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerMisViajesGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (loadOptions !== undefined && loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerMisViajesGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerMisViajesGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerMisViajesGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los viajes registrados de un transportista en especifico, con datos preparados para un DxDataGrid de DevExtreme
     * @param loadOptions (optional) 
     * @param transportistaId (optional) 
     */
    obtenerViajesPorIdGrid(loadOptions: DataSourceLoadOptions | null | undefined, transportistaId: string | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesPorIdGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (loadOptions !== undefined && loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + loadOptions) + "&";
        if (transportistaId === null)
            throw new Error("The parameter 'transportistaId' cannot be null.");
        else if (transportistaId !== undefined)
            url_ += "transportistaId=" + encodeURIComponent("" + transportistaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesPorIdGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesPorIdGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerViajesPorIdGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todos los viajes de un propietario, año y mes en especifico (usuario)
     * @param anio (optional) 
     * @param mes (optional) 
     * @param id (optional) Identificador unico del propietario (usuario)
     */
    obtenerViajesPropietario(anio: number | undefined, mes: number | undefined, id: string | undefined, area: string): Observable<ObtenerViajesGridRespuesta[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesPropietario?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesPropietario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesPropietario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajesGridRespuesta[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajesGridRespuesta[]>;
        }));
    }

    protected processObtenerViajesPropietario(response: HttpResponseBase): Observable<ObtenerViajesGridRespuesta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajesGridRespuesta[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener los detalles de un viaje en especifico
     * @param id (optional) 
     */
    obtenerViaje(id: string | undefined, area: string): Observable<DetallesViajeRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetallesViajeRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetallesViajeRespuesta>;
        }));
    }

    protected processObtenerViaje(response: HttpResponseBase): Observable<DetallesViajeRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DetallesViajeRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("El id de viaje no existe o fue eliminado", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No se envio un id valido", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener La lista de viajes de una fecha en especifico y en base a la tolerancia de la distancia entre el punto de origen, solo toma en cuenta hasta dia.
     */
    obtenerViajesFecha(peticion: ObtenerViajesFechaCoordenadasPeticion, area: string): Observable<ObtenerViajesGridRespuestaExtension[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesFecha";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesFecha(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajesGridRespuestaExtension[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajesGridRespuestaExtension[]>;
        }));
    }

    protected processObtenerViajesFecha(response: HttpResponseBase): Observable<ObtenerViajesGridRespuestaExtension[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajesGridRespuestaExtension[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retorna los posibles estados de un viaje para un combo
     */
    obtenerEstadosViaje(area: string): Observable<SelectListUtil[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerEstadosViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEstadosViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEstadosViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListUtil[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListUtil[]>;
        }));
    }

    protected processObtenerEstadosViaje(response: HttpResponseBase): Observable<SelectListUtil[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectListUtil[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener un viaje
     * @param id (optional) Identificador unico del viaje
     */
    obtenerViajePropietarioPorIdViaje(id: string | undefined, area: string): Observable<ObtenerViajesGridRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajePropietarioPorIdViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajePropietarioPorIdViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajePropietarioPorIdViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajesGridRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajesGridRespuesta>;
        }));
    }

    protected processObtenerViajePropietarioPorIdViaje(response: HttpResponseBase): Observable<ObtenerViajesGridRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajesGridRespuesta;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite que el chofer o el transportista den por iniciado uno de sus viajes
     * @param viajeId (optional) 
     */
    iniciarViaje(viajeId: string | undefined, area: string): Observable<void> {
        let url_ = this.baseUrl + "/{area}/Viaje/IniciarViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIniciarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIniciarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processIniciarViaje(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Indica si el transportista autenticado puede registrar viajes, para ello debe tener por lo menos una unidad de transporte y un chofer registrados
     */
    puedeRegistrarViajes(area: string): Observable<PuedeRegistrarViajesRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/PuedeRegistrarViajes";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPuedeRegistrarViajes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPuedeRegistrarViajes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PuedeRegistrarViajesRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PuedeRegistrarViajesRespuesta>;
        }));
    }

    protected processPuedeRegistrarViajes(response: HttpResponseBase): Observable<PuedeRegistrarViajesRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PuedeRegistrarViajesRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todos los viajes de un propietario, año y mes en especifico (usuario) para la app
     * @param anio (optional) 
     * @param mes (optional) 
     * @param id (optional) Identificador unico del propietario (usuario)
     * @param soloPendientes (optional) Para indicar si el se aplica el filtro de solo pendientes o se trae todos
     */
    obtenerViajesPropietarioApp(anio: number | undefined, mes: number | undefined, id: string | undefined, soloPendientes: boolean | undefined, area: string): Observable<ObtenerViajePropietarioApp[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesPropietarioApp?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (soloPendientes === null)
            throw new Error("The parameter 'soloPendientes' cannot be null.");
        else if (soloPendientes !== undefined)
            url_ += "soloPendientes=" + encodeURIComponent("" + soloPendientes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesPropietarioApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesPropietarioApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajePropietarioApp[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajePropietarioApp[]>;
        }));
    }

    protected processObtenerViajesPropietarioApp(response: HttpResponseBase): Observable<ObtenerViajePropietarioApp[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajePropietarioApp[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los viajes en los que participa el chofer autenticado
     * @param anio (optional) 
     * @param mes (optional) 
     * @param soloPendientes (optional) 
     */
    obtenerViajesChoferApp(anio: number | undefined, mes: number | undefined, soloPendientes: boolean | undefined, area: string): Observable<ObtenerViajePropietarioApp[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesChoferApp?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        if (soloPendientes === null)
            throw new Error("The parameter 'soloPendientes' cannot be null.");
        else if (soloPendientes !== undefined)
            url_ += "soloPendientes=" + encodeURIComponent("" + soloPendientes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesChoferApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesChoferApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajePropietarioApp[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajePropietarioApp[]>;
        }));
    }

    protected processObtenerViajesChoferApp(response: HttpResponseBase): Observable<ObtenerViajePropietarioApp[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajePropietarioApp[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los viajes en los que participa el chofer autenticado para mostrar en la web, sólo muestra seis
     * @param anio (optional) 
     * @param mes (optional) 
     */
    obtenerViajesChoferWeb(anio: number | undefined, mes: number | undefined, area: string): Observable<ObtenerViajePropietarioApp[]> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesChoferWeb?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (anio === null)
            throw new Error("The parameter 'anio' cannot be null.");
        else if (anio !== undefined)
            url_ += "anio=" + encodeURIComponent("" + anio) + "&";
        if (mes === null)
            throw new Error("The parameter 'mes' cannot be null.");
        else if (mes !== undefined)
            url_ += "mes=" + encodeURIComponent("" + mes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesChoferWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesChoferWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajePropietarioApp[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajePropietarioApp[]>;
        }));
    }

    protected processObtenerViajesChoferWeb(response: HttpResponseBase): Observable<ObtenerViajePropietarioApp[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajePropietarioApp[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve los viajes pendientes para un chofer en un grid en la web
     * @param options (optional) 
     */
    obtenerViajesChoferGrid(options: DataSourceLoadOptions | null | undefined, area: string): Observable<LoadResult> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajesChoferGrid?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajesChoferGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajesChoferGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadResult>;
        }));
    }

    protected processObtenerViajesChoferGrid(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo para obtener todos los viajes de un propietario en especifico (usuario) para la app
     * @param id (optional) Identificador unico del propietario (usuario)
     */
    obtenerViajePorIdApp(id: string | undefined, area: string): Observable<ObtenerViajePropietarioApp> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerViajePorIdApp?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerViajePorIdApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerViajePorIdApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerViajePropietarioApp>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerViajePropietarioApp>;
        }));
    }

    protected processObtenerViajePorIdApp(response: HttpResponseBase): Observable<ObtenerViajePropietarioApp> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerViajePropietarioApp;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Si no se ha iniciado sesi\u00f3n o no se cuenta con los permisos realizar pagos con tarjeta", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los detalles de un viaje de interés
     * @param viajeId (optional) 
     */
    obtenerDetallesViajeInteres(viajeId: string | undefined, area: string): Observable<ObtenerDetallesViajeInteresRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerDetallesViajeInteres?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesViajeInteres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesViajeInteres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesViajeInteresRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesViajeInteresRespuesta>;
        }));
    }

    protected processObtenerDetallesViajeInteres(response: HttpResponseBase): Observable<ObtenerDetallesViajeInteresRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesViajeInteresRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * En un viaje de interés, obtiene las distancias entre el cliente y el transportista
     */
    obtenerDistanciaViajeInteres(peticion: ObtenerDistanciaViajeInteresPeticion, area: string): Observable<ObtenerDistanciaViajeInteresRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerDistanciaViajeInteres";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDistanciaViajeInteres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDistanciaViajeInteres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDistanciaViajeInteresRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDistanciaViajeInteresRespuesta>;
        }));
    }

    protected processObtenerDistanciaViajeInteres(response: HttpResponseBase): Observable<ObtenerDistanciaViajeInteresRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDistanciaViajeInteresRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Metodo que devuleve los detalles y por menores de cancelar un viaje
     * @param viajeId (optional) 
     */
    obtenerDetallesViajeCancelacion(viajeId: string | undefined, area: string): Observable<ObtenerDetallesViajeCancelacionRespuesta> {
        let url_ = this.baseUrl + "/{area}/Viaje/ObtenerDetallesViajeCancelacion?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerDetallesViajeCancelacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerDetallesViajeCancelacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObtenerDetallesViajeCancelacionRespuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObtenerDetallesViajeCancelacionRespuesta>;
        }));
    }

    protected processObtenerDetallesViajeCancelacion(response: HttpResponseBase): Observable<ObtenerDetallesViajeCancelacionRespuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ObtenerDetallesViajeCancelacionRespuesta;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cancela un viaje
     */
    cancelarViaje(peticion: CancelarViajePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/CancelarViaje";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCancelarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permite a los transportistas y choferes dar por finalizado un viaje
     * @param viajeId (optional) 
     */
    finalizarViaje(viajeId: string | undefined, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/FinalizarViaje?";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        if (viajeId === null)
            throw new Error("The parameter 'viajeId' cannot be null.");
        else if (viajeId !== undefined)
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalizarViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalizarViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processFinalizarViaje(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Método que notifica la posición de un transporte al grupo de usuarios al que pertenece, de un viaje en especifico
     */
    notificarPosicionTrasporte(peticion: NotificarPosicionTrasportePeticion, area: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/{area}/Viaje/NotificarPosicionTrasporte";
        if (area === undefined || area === null)
            throw new Error("The parameter 'area' must be defined.");
        url_ = url_.replace("{area}", encodeURIComponent("" + area));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(peticion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificarPosicionTrasporte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificarPosicionTrasporte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processNotificarPosicionTrasporte(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ObtenerCategoriasViajePadreRespuesta {
    CategoriaViajeId: string;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    EsContenedor: boolean;
    EsIndefinido: boolean;
    Posicion: number;
    RequiereAlto: boolean;
    RequiereAncho: boolean;
    RequiereLargo: boolean;
    RequierePeso: boolean;
    RequiereTemperatura: boolean;
    ImagenCategoriaBase64?: string | undefined;
    TieneCategoriasHijas: boolean;
}

/** Represents a load result. */
export interface LoadResult {
    /** A resulting dataset. */
    data?: IEnumerable | undefined;
    /** The total number of data objects in the resulting dataset. */
    totalCount: number;
    /** The number of top-level groups in the resulting dataset. */
    groupCount: number;
    /** Total summary calculation results. */
    summary?: any[] | undefined;
}

export interface IEnumerable {
}

/** A class with properties that specify data processing settings. */
export interface DataSourceLoadOptionsBase {
    /** A flag indicating whether the total number of data objects is required. */
    RequireTotalCount: boolean;
    /** A flag indicating whether the number of top-level groups is required. */
    RequireGroupCount: boolean;
    /** A flag indicating whether the current query is made to get the total number of data objects. */
    IsCountQuery: boolean;
    /** The number of data objects to be skipped from the start of the resulting set. */
    Skip: number;
    /** The number of data objects to be loaded. */
    Take: number;
    /** A sort expression. */
    Sort?: SortingInfo[] | undefined;
    /** A group expression. */
    Group?: GroupingInfo[] | undefined;
    /** A filter expression. */
    Filter?: Filter[] | undefined;
    /** A total summary expression. */
    TotalSummary?: SummaryInfo[] | undefined;
    /** A group summary expression. */
    GroupSummary?: SummaryInfo[] | undefined;
    /** A select expression. */
    Select?: string[] | undefined;
    /** An array of data fields that limits the Select expression.
The applied select expression is the intersection of PreSelect and Select. */
    PreSelect?: string[] | undefined;
    /** A flag that indicates whether the LINQ provider should execute the select expression.
If set to false, the select operation is performed in memory. */
    RemoteSelect?: boolean | undefined;
    /** A flag that indicates whether the LINQ provider should execute grouping.
If set to false, the entire dataset is loaded and grouped in memory. */
    RemoteGrouping?: boolean | undefined;
    ExpandLinqSumType?: boolean | undefined;
    /** An array of primary keys. */
    PrimaryKey?: string[] | undefined;
    /** The data field to be used for sorting by default. */
    DefaultSort?: string | undefined;
    /** A flag that indicates whether filter expressions should include a ToLower() call that makes string comparison case-insensitive.
Defaults to true for LINQ to Objects, false for any other provider. */
    StringToLower?: boolean | undefined;
    /** If this flag is enabled, keys and data are loaded via separate queries. This may result in a more efficient SQL execution plan. */
    PaginateViaPrimaryKey?: boolean | undefined;
    SortByPrimaryKey?: boolean | undefined;
    AllowAsyncOverSync: boolean;
}

export interface DataSourceLoadOptions extends DataSourceLoadOptionsBase {
}

/** Represents a sorting parameter. */
export interface SortingInfo {
    /** The data field to be used for sorting. */
    Selector?: string | undefined;
    /** A flag indicating whether data should be sorted in a descending order. */
    Desc: boolean;
}

/** Represents a grouping level to be applied to data. */
export interface GroupingInfo extends SortingInfo {
    /** A value that groups data in ranges of a given length or date/time period. */
    GroupInterval?: string | undefined;
    /** A flag indicating whether the group's data objects should be returned. */
    IsExpanded?: boolean | undefined;
}

/** Represents a group or total summary definition. */
export interface SummaryInfo {
    /** The data field to be used for calculating the summary. */
    Selector?: string | undefined;
    /** An aggregate function: "sum", "min", "max", "avg", or "count". */
    SummaryType?: string | undefined;
}

/** Clase generica a utilizar en los dxSelectBox. */
export interface SelectListUtil {
    /** Texto a mostrar en los combos. */
    Name?: string | undefined;
    /** Valor a utlizar en los combos. */
    Value?: any | undefined;
}

export interface ObtenerCategoriasViajeHijasRespuesta extends ObtenerCategoriasViajePadreRespuesta {
    CategoriaViajePadreId?: string | undefined;
    CategoriaViajePadreNombre?: string | undefined;
}

export interface RegistrarCategoriaViajePeticion {
    /** Nombre de la categoria */
    Nombre: string;
    /** Descripción */
    Descripcion?: string | undefined;
    /** Identificador para espeficicar si es un contenedor */
    EsContenedor: boolean;
    EsIndefinido: boolean;
    Posicion?: number | undefined;
    RequiereAlto: boolean;
    RequiereAncho: boolean;
    RequiereLargo: boolean;
    RequierePeso: boolean;
    RequiereTemperatura: boolean;
    NombreImagenCategoriaViaje?: string | undefined;
    ImagenCategoriaBase64?: string | undefined;
    CategoriaViajePadreId?: string | undefined;
}

export interface EditarCategoriaViajePeticion extends RegistrarCategoriaViajePeticion {
    /** Id de la categoria que se va a editar */
    CategoriaViajeId: string;
}

/** Utilidad para devolver resultados páginados en endpoints */
export interface ResultadoPaginadoRespuestaOfObtenerCategoriasViajePadreRespuesta {
    /** Conteo total de objetos en base de datos */
    TotalObjetos: number;
    /** Total de páginas */
    TotalPaginas: number;
    /** Página en la que se navega */
    PaginaActual: number;
    TamanioPagina: number;
    /** Listado de objetos a iterar y mostrar */
    Objetos?: ObtenerCategoriasViajePadreRespuesta[] | undefined;
}

/** Utilidad para devolver resultados páginados en endpoints */
export interface ResultadoPaginadoRespuestaOfObtenerCategoriasViajeHijasRespuesta {
    /** Conteo total de objetos en base de datos */
    TotalObjetos: number;
    /** Total de páginas */
    TotalPaginas: number;
    /** Página en la que se navega */
    PaginaActual: number;
    TamanioPagina: number;
    /** Listado de objetos a iterar y mostrar */
    Objetos?: ObtenerCategoriasViajeHijasRespuesta[] | undefined;
}

/** Respuesta cuando se */
export interface RespuestaGuardadoArchivoTemporal {
    NombreArchivo?: string | undefined;
    ArchivoBase64?: string | undefined;
}

export interface Exception {
    Message: string;
    InnerException?: Exception | undefined;
    Source?: string | undefined;
    StackTrace?: string | undefined;
}

export interface RaiterException extends Exception {
    Mensaje?: string | undefined;
    Detalles?: string | undefined;
    Codigo?: string | undefined;
    ObjetoNegocio?: any | undefined;
    HttpStatusCode: HttpStatusCode;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

/** Clase con datos para el registro de un chofer */
export interface RegistrarChoferPeticion {
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    Email?: string | undefined;
    Telefono?: string | undefined;
    Ife?: string | undefined;
    NoLicencia?: string | undefined;
    TipoLicencia?: string | undefined;
    FechaNacimiento?: string | undefined;
    TransportistaId: string;
    /** Información adicional del chofer, por ejemplo certificaciones, intereses, logros, experiencia, etc. */
    InformacionExtra?: string[] | undefined;
    /** Nombre de archivo de la imagen de perfil del chofer dentro de su ubicación temporal */
    DatosFotoPerfil?: string | undefined;
    /** Nombre de archivo de la imagen frontal de la credencial de elector en ubicación temporal */
    DatosFotoIfeFrente?: string | undefined;
    /** Nombre de archivo de la imagen del reverso de la credencial de elector en ubicación temporal */
    DatosFotoIfeReverso?: string | undefined;
    /** Nombre de archivo de la imagen frontal de la licencia de conducir en ubicación temporal */
    DatosFotoLicenciaFrente?: string | undefined;
    /** Nombre de archivo de la imagen del reverso de la licencia de conducir en ubicación temporal */
    DatosFotoLicenciaReverso?: string | undefined;
    /** Imagen en base64 */
    DatosFotoPerfilBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoIfeFrenteBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoIfeReversoBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoLicenciaFrenteBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoLicenciaReversoBase64?: string | undefined;
}

/** Entidad que representa los choferes registrados para mostrarse en un grid de DevExtreme */
export interface ConsultaChoferRespuestaGrid {
    /** Identificador del chofer en base de datos */
    ChoferId: string;
    /** Nombres del chofer */
    Nombre?: string | undefined;
    /** Apellido paterno del chofer */
    Paterno?: string | undefined;
    /** Apellido materno del chofer */
    Materno?: string | undefined;
    /** Correo electrónico del chofer */
    CorreoElectronico?: string | undefined;
    /** Teléfono de contacto del chofer */
    Telefono?: string | undefined;
    /** Fecha de nacimiento del chofer */
    FechaNacimiento?: string | undefined;
    /** Clave de elector indicada en la credencial de elector del chofer */
    ClaveElector?: string | undefined;
    /** Número de la licencia de conducir */
    NumeroLicencia?: string | undefined;
    /** Tipo de la licencia de conducir */
    TipoLicencia?: string | undefined;
    /** Fecha en la que se registro en el sistema. */
    FechaRegistro: string;
    /** Indica si un chofer ya fue validado por los administrativos de raiter */
    EstaVerificado: boolean;
}

/** Clase para devolver datos del chofer registrado en un formulario de edición o sim0plemente consultarlo */
export interface ConsultaChoferRespuesta extends ConsultaChoferRespuestaGrid {
    Transportista?: ConsultaChoferTransportistaRespuesta | undefined;
    DatosVerificacion?: ConsultaChoferDatosVerificacionRespuesta | undefined;
    /** Información adicional del chofer, por ejemplo certificaciones, intereses, logros, experiencia, etc. */
    InformacionExtra?: string[] | undefined;
    FotoPerfilId?: string | undefined;
    /** Foto de perfil del chofer en base 64 */
    FotoPerfilBase64?: string | undefined;
    FotoIneFrenteId?: string | undefined;
    /** Foto frontal del INE del chofer en base 64 */
    FotoIneFrenteBase64?: string | undefined;
    FotoIneVueltaId?: string | undefined;
    /** Foto del reverso del INE del chofer en base 64 */
    FotoIneVueltaBase64?: string | undefined;
    FotoLicenciaFrenteId?: string | undefined;
    /** Foto frontal de la licencia del chofer en base 64 */
    FotoLicenciaFrenteBase64?: string | undefined;
    FotoLicenciaVueltaId?: string | undefined;
    /** Foto del reverso de la licencia del chofer en base 64 */
    FotoLicenciaVueltaBase64?: string | undefined;
}

export interface ObtenerChoferPorIdAdminRespuesta extends ConsultaChoferRespuesta {
    Usuario?: ObtenerUsuariosRespuesta | undefined;
}

export interface ObtenerUsuariosRespuesta {
    /** Identificador único del usuario. */
    Id?: string | undefined;
    /** Nombre o alias del usuario. */
    UserName?: string | undefined;
    /** Nombre del usuario */
    Nombre?: string | undefined;
    /** Apellido paterno del usuario */
    Paterno?: string | undefined;
    /** Apellido materno del usuario */
    Materno?: string | undefined;
    /** Correo electrónico donde recibira mensajes de ayuda, error o notificaciones. */
    Email?: string | undefined;
    /** Número telefonico fijo o móvil por el cual se localizara la usuario. */
    PhoneNumber?: string | undefined;
    /** Fecha en la que se registro en el sistema. */
    FechaRegistro: string;
    /** Rol/Perfil asignado al usuario. */
    Rol?: string | undefined;
    /** Indica si el usuario está activo en plataforma o no */
    EstaActivo: boolean;
    TransportistaId?: string | undefined;
    Transportista?: ObtenerUsuariosTrasnportisaRespuesta | undefined;
}

export interface ObtenerUsuariosTrasnportisaRespuesta {
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    EstadoVerificacion?: ObtenerTransportistaVerificacionesGridRespuesta | undefined;
}

export interface ObtenerTransportistaVerificacionesGridRespuesta {
    TransportistaVerificacionId: string;
    FechaRegistro: string;
    Comentarios?: string | undefined;
    Estado: EstadoAprobacionTransportista;
    EstadoString?: string | undefined;
    UsuarioValido?: string | undefined;
}

export enum EstadoAprobacionTransportista {
    EnProceso = 0,
    Rechazado = 1,
    Aprobado = 2,
}

export interface ConsultaChoferTransportistaRespuesta {
    /** Identificador del usuario raiter asociado a este chofer */
    TransportistaId?: string | undefined;
    /** Transportista/Empresa a la que pertenece el chofer */
    TransportistaString?: string | undefined;
    /** Nombre del usuario raiter asociado a este chofer. */
    TransportistaNombreComercial?: string | undefined;
    /** Nombre de usuario */
    UserName?: string | undefined;
    /** Identifica si el usuario esta activo en plataforma */
    EstaActivo: boolean;
}

export interface ConsultaChoferDatosVerificacionRespuesta {
    /** Fecha en la que se realizo la validación del chofer. */
    FechaValidacion: string;
    /** Nombre del usuario que valido al chofer. */
    UsuarioValidoString?: string | undefined;
}

/** Clase con datos para la edición de chofer */
export interface EditarChoferPeticion extends RegistrarChoferPeticion {
    /** Identificador del chofer que se edita */
    ChoferId: string;
}

export interface ObtenerChoferesPorUsuarioRespuesta {
    ChoferId: string;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    CorreoElectronico?: string | undefined;
    Telefono?: string | undefined;
    FechaNacimiento?: string | undefined;
    ClaveElector?: string | undefined;
    NumeroLicencia?: string | undefined;
    TipoLicencia?: string | undefined;
    FechaRegistro: string;
    Foto64?: string | undefined;
}

export interface ChoferComboRespuesta {
    ChoferId: string;
    Nombre?: string | undefined;
}

/** Información posterior a que una imagen de chofer ha sido colocada en una ubicación temporal previo a la culminación del proceso de registro o edición */
export interface ChoferImagenRespuesta {
    /** Nombre del archivo subido en la ubicación temporal para su posterior traslado a una carpeta definitiva */
    NombreArchivo?: string | undefined;
    /** Imagen en formato base64 para visualizarlo en el formulario. */
    ImagenBase64?: string | undefined;
}

export interface ContactoEmergenciaRespuesta {
    ContactoEmergenciaId: string;
    NumeroCelular?: string | undefined;
    Descripcion?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface ContactoEmergenciaRegistrarPeticion {
    NumeroCelular?: string | undefined;
    Descripcion?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface ContactoEmergenciaEditarPeticion {
    ContactoEmergenciaId: string;
    NumeroCelular?: string | undefined;
    Descripcion?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface RegistrarDatoFacturacionPeticion {
    UsuarioId?: string | undefined;
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    RegimenFiscalReceptor?: string | undefined;
    UsoCfdiReceptor?: string | undefined;
    DomicilioFiscalReceptor?: string | undefined;
}

export interface EditarDatoFacturacionPeticion extends RegistrarDatoFacturacionPeticion {
    DatoFacturacionId: string;
}

export interface ObtenerDatosFacturacionRespuesta {
    DatoFacturacionId: string;
    FechaRegistro: string;
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    Calle?: string | undefined;
    CodigoPostal?: string | undefined;
    Colonia?: string | undefined;
    RegimenFiscal?: string | undefined;
    UsoCfdi?: string | undefined;
    DomicilioFiscal?: string | undefined;
    RegimenFiscalSatId?: string | undefined;
    UsoCfdiSatId?: string | undefined;
}

export interface IniciarDevolucionOpenpayPeticion {
    SolicitudViajePagoOpenpayId: string;
    MedioDevolucion: MedioDevolucion;
    NumeroDevolucion?: string | undefined;
    UsuarioId?: string | undefined;
}

export enum MedioDevolucion {
    Tarjeta = 0,
    Banco = 1,
}

export interface DispositivoMovilRespuesta {
    DispositivoMovilId: string;
    DispositivoMovilSerial?: string | undefined;
    Modelo?: string | undefined;
    TokenFirebase?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface DispositivoMovilRegistrarPeticion {
    DispositivoMovilSerial?: string | undefined;
    Modelo?: string | undefined;
    TokenFirebase?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface DispositivoMovilEditarPeticion {
    DispositivoMovilId: string;
    DispositivoMovilSerial?: string | undefined;
    Modelo?: string | undefined;
    TokenFirebase?: string | undefined;
    PropietarioId?: string | undefined;
}

export interface RegistrarDocumentoSolicitudPeticion {
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    SolicitudId: string;
}

export interface DocumentoSolicitudRespuesta {
    DocumentoSolicitudId: string;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
}

/** Respuesta a la peticion de timbrado */
export interface TimbrarServiceResponse {
    /** Si se realizo la operacion */
    IsDone: boolean;
    /** Cfdi Xml arreglo de bytes */
    CfdiBytes?: string | undefined;
    /** Formato Pdf */
    CfdiPdfBytes?: string | undefined;
    /** Formato Jpeg */
    CfdiJpegBytes?: string | undefined;
    /** Uuid del Cfdi que fue timbrado. */
    Uuid?: string | undefined;
    /** El número del ticket que fue timbrado en caso que sea multiple van separados por coma. */
    CurrentReferenceNumber?: string | undefined;
    /** Si el cfdi esta cancelado entonces debe contener un acuse */
    AcuseCancelacion?: string | undefined;
    /** Si está cancelado el cfdi */
    IsCancelado: boolean;
    /** Cfdi Guid */
    CfdiGuid: string;
    /** Folio Interno */
    FolioInterno?: string | undefined;
    /** Si en el proceso sucedieron incidentes que es necesario reportar. */
    Logs?: string | undefined;
}

export interface TimbrarVentaPeticion {
    Venta?: Venta | undefined;
    /** Correo electronico a donde sera enviada la factura */
    CorreosElectronicos?: string[] | undefined;
    /** Direccion que se asigna en leyendas fiscales */
    Direccion?: string | undefined;
    /** Posibilidad de adherir complementos al Cfdi */
    Complementos?: any[] | undefined;
    EsPreliminar: boolean;
    /** Clave sat de uso del cfdi */
    ClaveUsoCfdi?: string | undefined;
}

export interface Venta {
    VentaId: string;
    ReferenciaInterna?: string | undefined;
    RequiereHomologarSat: boolean;
    Total: number;
    SubTotal: number;
    TotalIva?: number | undefined;
    TotalIeps?: number | undefined;
    TotalImpuestosTrasladados?: number | undefined;
    TotalDescuento?: number | undefined;
    EstaCancelado: boolean;
    FechaCancelacion?: string | undefined;
    Referencia?: string | undefined;
    FechaApertura: string;
    FechaEmision: string;
    Comentario?: string | undefined;
    NumeroMovimientos: number;
    Establecimiento?: VentaEstablecimiento | undefined;
    Cliente?: VentaCliente | undefined;
    VentaClienteId?: string | undefined;
    Conceptos?: VentaConcepto[] | undefined;
    Pagos?: VentaPago[] | undefined;
    ClaveMetodoPago?: string | undefined;
    ClaveMetodoPagoDescripcion?: string | undefined;
    VentaJsonArchivoId?: string | undefined;
    VentaJsonArchivo?: VentaJsonArchivo | undefined;
    VentaOrigenArchivoId?: string | undefined;
    VentaOrigenArchivo?: VentaOrigenArchivo | undefined;
    ReferenciaPrevia?: string | undefined;
    Cargos?: VentaCargo[] | undefined;
    TotalCargos?: number | undefined;
    TotalConCargos: number;
    ClaveMetodoPagoSat?: string | undefined;
}

export interface VentaEstablecimiento {
    VentaEstablecimientoId: string;
    Clave?: string | undefined;
    Nombre?: string | undefined;
    Titulo?: string | undefined;
    Descripcion?: string | undefined;
}

export interface VentaCliente {
    VentaClienteId: string;
    Clave?: string | undefined;
    NombreComercial?: string | undefined;
    ResidenciaFiscalSat?: string | undefined;
    NumRegIdTribSat?: string | undefined;
    UsoCfdi?: string | undefined;
    Rfc?: string | undefined;
    Nombre?: string | undefined;
}

export interface VentaConcepto {
    VentaConceptoId: string;
    Descripcion?: string | undefined;
    ClaveProdServ?: string | undefined;
    NoIdentificacion?: string | undefined;
    Cantidad: number;
    ClaveUnidad?: string | undefined;
    Unidad?: string | undefined;
    ValorUnitario: number;
    Importe: number;
    Descuento: number;
    Venta?: Venta | undefined;
    VentaId: string;
    Impuestos?: VentaConceptoImpuesto[] | undefined;
}

export interface VentaConceptoImpuesto {
    VentaConceptoImpuestoId: string;
    Nombre?: string | undefined;
    TasaOCuota: number;
    Importe: number;
    Base: number;
    Clave?: string | undefined;
    TipoFactor?: string | undefined;
    Concepto?: VentaConcepto | undefined;
    ConceptoId: string;
}

export interface VentaPago {
    VentaPagoId: string;
    Fecha: string;
    Monto: number;
    ClaveFormaPago?: string | undefined;
    ClaveFormaPagoDescripcion?: string | undefined;
    CodigoMoneda?: string | undefined;
    Venta?: Venta | undefined;
    VentaId: string;
    TipoCambio?: PagoTipoCambio | undefined;
    TipoCambioId?: string | undefined;
    ClaveFormaPagoSat?: string | undefined;
}

export interface PagoTipoCambio {
    FechaCambio: string;
    CodigoMonedaOrigen?: string | undefined;
    CodigoMonedaDestino?: string | undefined;
    TipoCambio: number;
}

export interface VentaJsonArchivo {
    VentaJsonArchivoId: string;
    RutaAbsoluta?: string | undefined;
    RutaVirtual?: string | undefined;
    Nombre?: string | undefined;
    Tamanio: number;
    TipoMime?: string | undefined;
    Hash?: string | undefined;
    FechaRegistro: string;
    FechaModificacion?: string | undefined;
    EntidadRegistro?: string | undefined;
    EntidadModifico?: string | undefined;
    IdentificadorEntidadRegistro?: string | undefined;
    IdentificadorEntidadModifico?: string | undefined;
}

export interface VentaOrigenArchivo {
    VentaOrigenArchivoId: string;
    RutaAbsoluta?: string | undefined;
    RutaVirtual?: string | undefined;
    Nombre?: string | undefined;
    Tamanio: number;
    TipoMime?: string | undefined;
    Hash?: string | undefined;
    FechaRegistro: string;
    FechaModificacion?: string | undefined;
    EntidadRegistro?: string | undefined;
    EntidadModifico?: string | undefined;
    IdentificadorEntidadRegistro?: string | undefined;
    IdentificadorEntidadModifico?: string | undefined;
}

export interface VentaCargo {
    IdVentaVentaCargo: string;
    DesgloseCfdi: boolean;
    ClaveProdServ?: string | undefined;
    NoIdentificacion?: string | undefined;
    Cantidad: number;
    ClaveUnidad?: string | undefined;
    Unidad?: string | undefined;
    Descripcion?: string | undefined;
    ValorUnitario: number;
    Importe: number;
    Descuento: number;
    Tipo: CargoTipo;
    TipoDescripcion?: string | undefined;
    Venta?: Venta | undefined;
    VentaId: string;
    Impuestos?: VentaCargoImpuesto[] | undefined;
}

export enum CargoTipo {
    Propina = 0,
}

export interface VentaCargoImpuesto {
    VentaCargoImpuestoId: string;
    Nombre?: string | undefined;
    TasaOCuota: number;
    Importe: number;
    Base: number;
    Clave?: string | undefined;
    TipoFactor?: string | undefined;
    Cargo?: VentaCargo | undefined;
    CargoId: string;
}

export interface EnviarCfdiCorreoPorCfdGuidPeticion {
    CfdGuid: string;
    CorreosElectronicos?: string[] | undefined;
}

export interface EnviarCfdiCorreoPorUuidPeticion {
    UuidCfdi?: string | undefined;
    CorreosElectronicos?: string[] | undefined;
}

export interface ValidarCfdResponse {
    Estado?: string | undefined;
    CodigoEstatus?: string | undefined;
    EsCancelable?: string | undefined;
    EstatusCancelacion?: string | undefined;
}

export interface ObtenerUsosCfdiRespuesta {
    name?: string | undefined;
    value?: string | undefined;
    UsoCfdiString?: string | undefined;
}

export interface TimbrarSolicitudViajePeticion {
    SolicitudViajeId: string;
    DatoFacturacionId: string;
    UsoCfdi?: string | undefined;
}

export interface SolicitudViajeFacturaRespuesta {
    SolicitudViajeFacturaCfdiId: string;
    CfdiGuid: string;
    Uuid?: string | undefined;
}

export interface ObtenerEstableciminetosRespuesta {
    EstablecimientoGuid: string;
    Clave?: string | undefined;
}

/** Clase utilitaria para manejar objetos select */
export interface SelectListUtil2 {
    name?: string | undefined;
    value?: string | undefined;
}

export interface FirebaseNotificacionRespuesta {
    /** Identificador único de la entidad. */
    FirebaseNotificacionId: string;
    /** Identificador unico del usuario o Nombre del topico/grupo de usuarios al que se envio la notificacion */
    IdOTopico?: string | undefined;
    /** Titulo que se visualizará para la notificacion */
    Titulo?: string | undefined;
    /** Titulo que se visualizará para la notificacion */
    Subtitulo?: string | undefined;
    /** Cuerpo del mensaje que se visualizará en la notificación */
    Cuerpo?: string | undefined;
    /** Icono que se visualizará en la notificacion */
    Icono: IconoNotificacion;
    /** Descripcion del icono de la notificacion */
    IconoDescripcion?: string | undefined;
    /** Url de la imagen que se visualizará en la notificacion p.ej. http://imagenes.com/imagen.png */
    UrlImagen?: string | undefined;
    /** Identificador unico del usuario a quien va dirigida la notifición (opcional cuando la notificación va dirigida a un topico/grupo) */
    UsuarioId?: string | undefined;
    FechaRegistro: string;
    /** Para indicar el tipo de la notificacion y aplicar una logica */
    TipoNotificacion: number;
    /** Descripcion del tipo de la notificacion */
    TipoNotificacionString?: string | undefined;
    /** Para regresar un guid, json dependiendo del tipo de notificacion */
    ObjetoNotificacion?: string | undefined;
    /** Para saber si la notificacion ya ha sido vista o dado click */
    Leida: boolean;
}

export enum IconoNotificacion {
    Ic_letras = 0,
}

/** Clase con información para la página principal (Home) como número de clientes, choferes, pagos e ingresos de un mes seleccionado */
export interface DashboardRespuesta {
    /** Número de clientes registrados en plataforma */
    NoClientes: number;
    /** Número de choferes registrados en plataforma */
    NoChoferes: number;
    /** Número de transacciones de pago registradas en la plataforma del mes seleccionado */
    NoPagos: number;
    /** Ingresos obtenidos de pagos completados dentro de un mes seleccionadop */
    IngresosMensuales: number;
}

/** Datos para representar el número de pagos en un mes seleccionado */
export interface NoPagosRespuesta {
    /** Dia del mes seleccionado */
    Dia: number;
    /** No de pagos del día incluyendo aquellos mediante tarjeta y referencia bancaria */
    NoPagos: number;
}

/** Datos para representar los ingresos de un mes */
export interface IngresosMensualesRespuesta {
    /** Dia del mes seleccionad */
    Dia: number;
    /** Monto ingresado en el día seleccionado */
    Monto: number;
}

export interface RegistrarIncidenciaViajePeticion {
    Ubicacion?: string | undefined;
    Direccion?: string | undefined;
    Descripcion?: string | undefined;
    ViajeId: string;
    ChoferId: string;
    ImagenIncidenciaBase64?: string | undefined;
    TipoIncidencia: TipoIncidenciaViaje;
    AplicaSeguro: boolean;
    CausaCancelacionViaje: boolean;
    DatosRetraso?: RegistrarViajeRetrasoPeticion | undefined;
}

export enum TipoIncidenciaViaje {
    Accidente = 0,
    Retraso = 1,
    Falla_Mecanica = 2,
}

export interface RegistrarViajeRetrasoPeticion {
    Dias: number;
    Horas: number;
    Minutos: number;
}

export interface LugarInteresRespuesta {
    LugarInteresId: string;
    Estado?: string | undefined;
    Municipio?: string | undefined;
    UsuarioId?: string | undefined;
    SepomexId: string;
}

export interface RegistrarLugarInteresPeticion {
    SepomexId: string;
    UsuarioId?: string | undefined;
}

export interface EditarLugarInteresPeticion extends RegistrarLugarInteresPeticion {
    LugarInteresId: string;
}

export interface ObtenerDetallesGeneralesPagoRespuesta {
    SolicitudViajePagoId: string;
    Monto: number;
    EstadoPago?: string | undefined;
    FormaPago?: string | undefined;
    Pasarela: TipoPasarela;
    PasarelaString?: string | undefined;
    FechaPago?: string | undefined;
    DescripcionPago?: string | undefined;
    SolicitudViajeId: string;
    UuidCfdi?: string | undefined;
    SolicitudViajePagoOpenpayIds?: string[] | undefined;
}

export enum TipoPasarela {
    Openpay = 0,
}

export interface ObtenerPagosGridRespuesta {
    SolicitudViajePagoId: string;
    SolicitudViajeId: string;
    TipoPasarela: TipoPasarela;
    MontoPorPagar: number;
    FechaRegistro: string;
    FechaPago?: string | undefined;
    EstadoPago?: string | undefined;
    ViajeString?: string | undefined;
    UuidCfdi?: string | undefined;
    TipoPasarelaString?: string | undefined;
}

/** Clase para respuestas de cargos/pagos creados a través de tarjeta */
export interface PagoTarjetaRespuesta {
    PagoTarjetaId: string;
    IdentificadorEntidadPasarelaOpenpay?: string | undefined;
    IdentificadorOrdenPasarelaOpenpay?: string | undefined;
    IdentificadorClientePasarelaOpenpay?: string | undefined;
    /** Importe registrado en el cargo */
    Importe: number;
    /** Descripción registrada en el cargo */
    Descripcion?: string | undefined;
    /** Estado del pago */
    Estatus?: string | undefined;
    /** Mensaje de error en caso de existir */
    MensajeError?: string | undefined;
    /** Parcialidad en caso de tratarse de paga por parcialidades */
    Parcialidad: number;
    /** Moneda en la que se realiza el pago */
    Moneda?: string | undefined;
    /** Autorización bancaria */
    Autorizacion?: string | undefined;
    /** Valor que indica si se usa la tecnología 3D Secure para este pago con tarjeta */
    Usar3DSecure: boolean;
    /** Url a la que redirigir, usado más en transacciones con 3D Secure */
    UrlRedireccion?: string | undefined;
    FechaCreacionPasarelaOpenpay?: string | undefined;
    /** Fecha en que se completó el pago, en caso de que ya se haya hecho exitosamente */
    FechaPagoConcretado?: string | undefined;
    /** Folio interno de la compra realizada */
    FolioCompra?: string | undefined;
    /** Nombre del cliente que ha efecturado la compra */
    NombreCliente?: string | undefined;
    /** Email del clietne para envio del correo */
    EmailCliente?: string | undefined;
    UltimosCuatroDigitosTarjeta?: string | undefined;
    /** Id en base de datos de la compra */
    CompraId: string;
    /** Id de la solicitud de viaje relacionada */
    SolicitudViajeId: string;
    EstadoSolicitud: EstadoSolicitudViaje;
    EstadoSolicitudString?: string | undefined;
    /** Datos para elaborar comprobante en caso de pago exitoso, será nulo si el pago aún no se ha completado */
    ComprobanteExito?: ComprobantePagoExitosoRespuesta | undefined;
}

export enum EstadoSolicitudViaje {
    Pendiente = 0,
    Aceptada = 1,
    Rechazada = 2,
    PagoPendiente = 3,
    PagoNoCompletado = 4,
    Pagada = 5,
    Completada = 6,
    Cancelada = 7,
}

/** Comprobante de pago exitoso devuelto al cliente */
export interface ComprobantePagoExitosoRespuesta {
    /** Folio del comprobante o compra */
    Folio?: string | undefined;
    /** Fecha en que se confirma el éxito del pago */
    FechaGeneracion: string;
    /** Título o encabezado del comprobante */
    Titulo?: string | undefined;
    /** Descripcion/Mensaje/Contenido que acompaña el comprobante */
    Mensaje?: string | undefined;
    /** Importe recibido */
    Importe: number;
    /** Código de moneda en que se pago */
    Moneda?: string | undefined;
    /** E-mail del usuario donde se envía el comprobante */
    Email?: string | undefined;
    /** Persona o empresa que ha recibido el pago */
    Beneficiario?: string | undefined;
    /** Nombre del cliente que ha realizado el pago */
    NombreCliente?: string | undefined;
    FormaPago?: string | undefined;
    Autorizacion?: string | undefined;
}

/** Datos para registrar una tarjeta con tokens, para que la información de la tarjeta viaje segura */
export interface RegistrarTarjetaTokenPeticion {
    /** Id del usuario raiter que realiza el pago */
    UsuarioId?: string | undefined;
    /** Token generado con la información de la tarjeta */
    TokenId?: string | undefined;
    /** Id proporcionado con la herramienta antifraudes */
    DeviceSessionId?: string | undefined;
}

/** Clase que contiene los campos para poder crear un cargo en Openpay */
export interface PagoTarjetaPeticion extends RegistrarTarjetaTokenPeticion {
    /** Identificador externo único de la transacción, campo opcional */
    OrdenId?: string | undefined;
    /** Id de la solicitud del viaje que está por pagarse */
    SolicitudViajeId: string;
    /** Define de si la llamada se esta realizando desde la app de raiter */
    OrigenRaiterApp: boolean;
}

export interface GenerarRefererenciaOpenpayRespuesta {
    SolicitudViajePagoOpenPayId: string;
    Bytes?: string | undefined;
    Referencia?: string | undefined;
}

export interface OpenpayNotificacionPeticion {
    type?: string | undefined;
    event_date: string;
    verification_code?: string | undefined;
    id?: string | undefined;
    transaction?: Transaction | undefined;
}

export interface Transaction {
    id?: string | undefined;
    authorization?: string | undefined;
    operation_type?: string | undefined;
    transaction_type?: string | undefined;
    status?: string | undefined;
    conciliated: boolean;
    creation_date: string;
    operation_date?: string | undefined;
    description?: string | undefined;
    error_message?: string | undefined;
    order_id?: string | undefined;
    customer_id?: string | undefined;
    due_date: string;
    amount: number;
    card?: Card | undefined;
    refunds?: RefundElement[] | undefined;
    refund?: PurpleRefund | undefined;
    fee?: Fee | undefined;
    payment_method?: PaymentMethod | undefined;
    customer?: CustomerNotificacion | undefined;
    currency?: string | undefined;
    method?: string | undefined;
    error_code?: number | undefined;
}

export interface Card {
    type?: string | undefined;
    brand?: string | undefined;
    address?: string | undefined;
    card_number?: string | undefined;
    holder_name?: string | undefined;
    expiration_year?: string | undefined;
    expiration_month?: string | undefined;
    allows_charges: boolean;
    allows_payouts: boolean;
    bank_name?: string | undefined;
    points_type?: string | undefined;
    bank_code?: string | undefined;
    points_card: boolean;
}

export interface RefundElement {
    operation_date: string;
    authorization?: string | undefined;
    amount: number;
    status?: string | undefined;
    conciliated: boolean;
    id?: string | undefined;
    description?: string | undefined;
    fee?: Fee | undefined;
    currency?: string | undefined;
}

export interface Fee {
    amount: number;
    tax: number;
    currency?: string | undefined;
}

export interface PurpleRefund {
    operation_date: string;
    authorization?: string | undefined;
    amount: number;
    operation_type?: string | undefined;
    method?: string | undefined;
    transaction_type?: string | undefined;
    status?: string | undefined;
    conciliated: boolean;
    id?: string | undefined;
    creation_date: string;
    description?: string | undefined;
    customer?: CustomerNotificacion | undefined;
    fee?: Fee | undefined;
    currency?: string | undefined;
    error_message?: string | undefined;
}

export interface CustomerNotificacion {
    name?: string | undefined;
    last_name?: string | undefined;
    email?: string | undefined;
    phone_number?: string | undefined;
    address?: any | undefined;
    creation_date: string;
    external_id?: any | undefined;
    clabe?: any | undefined;
}

export interface PaymentMethod {
    type?: string | undefined;
    bank?: string | undefined;
    clabe?: string | undefined;
    agreement?: string | undefined;
    name?: string | undefined;
}

export interface ObtenerDetallesPagoOpenpayRespuesta {
    SolicitudViajePagoOpenpayId: string;
    EstadoPago: EstadoPagoOpenpay;
    EstadoPagoString?: string | undefined;
    MetodoPago: MetodoPagoOpenpay;
    MetodoPagoString?: string | undefined;
    FechaLimite?: string | undefined;
    Autorizacion?: string | undefined;
    DigitosTarjeta?: string | undefined;
    MensajeError?: string | undefined;
    DatosReferencia?: DatosReferenciaOpenpayRespuesta | undefined;
    DevolucionTarjetaOpenpay?: DevolucionTarjetaOpenpayRespuesta | undefined;
    DevolucionPagoCuentaBancaria?: DevolucionPagoCuentaBancariaRespuesta | undefined;
}

export enum EstadoPagoOpenpay {
    EnProceso = 0,
    Fallido = 1,
    Completado = 2,
    Expirado = 3,
}

export enum MetodoPagoOpenpay {
    NoIdentificado = 0,
    Tarjeta = 1,
    Banco = 2,
    Cliente = 3,
    Tienda = 4,
}

export interface DatosReferenciaOpenpayRespuesta {
    TipoReferencia: TipoReferenciaOpenpay;
    DatosReferenciaOpenpayId: string;
    TipoReferenciaString?: string | undefined;
    NumReferencia?: string | undefined;
}

export enum TipoReferenciaOpenpay {
    NoDefinido = 0,
    Banco = 1,
    Tienda = 2,
    Redireccion = 3,
}

export interface DevolucionTarjetaOpenpayRespuesta {
    FechaRegistro: string;
    Monto: number;
    Moneda?: string | undefined;
    Descripcion?: string | undefined;
    Autorizacion?: string | undefined;
}

export interface DevolucionPagoCuentaBancariaRespuesta {
    FechaDesposito?: string | undefined;
    /** Número de tarjeta a donde se le puede devolver al cliente */
    NumeroTarjetaDevolucion?: string | undefined;
    /** CLABE interbancaria a la que se le puede devolver al cliente */
    ClabeInterbancariaDevolucion?: string | undefined;
    /** Medio por el cual devolver, tarjeta o banco */
    MedioDevolucion?: MedioDevolucion | undefined;
    MedioDevolucionString?: string | undefined;
    Estado?: EstadoPagoOpenpay | undefined;
    EstadoString?: string | undefined;
    Cargos?: DevolucionPagoCuentaBancariaCargoRespuesta[] | undefined;
}

export interface DevolucionPagoCuentaBancariaCargoRespuesta {
    Motivo?: string | undefined;
    TipoFactor: TipoFactor;
    TipoFactorString?: string | undefined;
    TasaOCuota: number;
}

export enum TipoFactor {
    Tasa = 0,
    Cuota = 1,
}

export interface PostulacionViajeRespuesta {
    PostulacionViajeId: string;
    /** Geo-punto codificado para representar en mapa la ubicación destino */
    UbicacionDestino?: string | undefined;
    /** Nombre de la dirección destino ingresada */
    DireccionUbicacionDestino?: string | undefined;
    /** Geo-punto codificado para representar en mapa la ubicación origen */
    UbicacionOrigen?: string | undefined;
    /** Nombre de la dirección origen ingresada */
    DireccionUbicacionOrigen?: string | undefined;
    EstadoOrigen?: string | undefined;
    MunicipioOrigen?: string | undefined;
    EstadoDestino?: string | undefined;
    MunicipioDestino?: string | undefined;
    FechaRegistro: string;
    FechaSalida: string;
    EstadoPostulacionViaje: EstadoPostulacionViaje;
    EstadoPostulacionViajeString?: string | undefined;
    ViajeRealizadoEnApp?: boolean | undefined;
    UsuarioId?: string | undefined;
    Categoria?: string | undefined;
    CategoriaId?: string | undefined;
    TipoTransporte?: string | undefined;
    TipoTransporteId?: string | undefined;
    Comentario?: string | undefined;
    Peso: number;
    UnidadMedidaPesoId?: string | undefined;
    UnidadMedidaPeso?: string | undefined;
    Ancho: number;
    UnidadMedidaAnchoId?: string | undefined;
    UnidadMedidaAncho?: string | undefined;
    Alto: number;
    UnidadMedidaAltoId?: string | undefined;
    UnidadMedidaAlto?: string | undefined;
    Largo: number;
    UnidadMedidaLargoId?: string | undefined;
    UnidadMedidaLargo?: string | undefined;
    Temperatura?: number | undefined;
    UnidadMedidaTemperaturaId?: string | undefined;
    UnidadMedidaTemperatura?: string | undefined;
    CuidadosEspeciales?: string | undefined;
    SustanciaPeligrosaId?: string | undefined;
    SustanciaPeligrosa?: string | undefined;
    SepomexDestinoId?: string | undefined;
    SepomexOrigenId?: string | undefined;
}

export enum EstadoPostulacionViaje {
    Pendiente = 0,
    Cancelada = 1,
    Finalizada = 2,
}

export interface PostulacionViajeUsuarioRespuesta extends PostulacionViajeRespuesta {
    NumViajesRelacionados: number;
}

export interface RegistrarPostulacionViajePeticion {
    /** Geo-punto codificado para representar en mapa la ubicación destino */
    UbicacionDestino?: string | undefined;
    /** Nombre de la dirección destino ingresada */
    DireccionUbicacionDestino?: string | undefined;
    /** Geo-punto codificado para representar en mapa la ubicación origen */
    UbicacionOrigen?: string | undefined;
    /** Nombre de la dirección origen ingresada */
    DireccionUbicacionOrigen?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    FechaSalida: string;
    UsuarioId?: string | undefined;
    CategoriaId: string;
    TipoTransporteId?: string | undefined;
    Comentario?: string | undefined;
    Peso: number;
    UnidadMedidaPesoId?: string | undefined;
    Ancho: number;
    UnidadMedidaAnchoId?: string | undefined;
    Alto: number;
    UnidadMedidaAltoId?: string | undefined;
    Largo: number;
    UnidadMedidaLargoId?: string | undefined;
    Temperatura: number;
    UnidadMedidaTemperaturaId?: string | undefined;
    CuidadosEspeciales?: string | undefined;
    SustanciaPeligrosaId?: string | undefined;
}

export interface EditarPostulacionViajePeticion extends RegistrarPostulacionViajePeticion {
    PostulacionViajeId: string;
}

/** Datos para finalizar una postulación de viaje */
export interface FinalizarPostulacionViajePeticion {
    /** Id de la postulación de viaje que va a finalizarse */
    PostulacionViajeId: string;
    /** Indica si el usuario ya realizó el viaje que solicitaba, si se indica falso se da la postulación por cancelada */
    ViajeRealizado: boolean;
    /** Permite indicar si el viaje se realizó a través de la app de Raiter */
    ViajeRealizadoEnApp: boolean;
}

export interface PostulacionViajeTransportistaRespuesta {
    /** Id de la postulación de viaje relacionado */
    PostulacionViajeId: string;
    /** Id del transportista al que posiblemente le pueda interesar el viaje */
    TransportistaId: string;
    /** Indica si el transportista marcó que le interesa la postulación */
    LeIntereso: boolean;
    /** Observaciones realizadas por el transportista  */
    Observaciones?: string | undefined;
    /** Estado de la postulación marcada como de interés para el transportista, puede ser en negociación, rechazada o aceptada */
    Estado?: EstadoPostulacionViajeTransportista | undefined;
    /** Representación del estado en formato cadena */
    EstadoString?: string | undefined;
    Postulacion?: PostulacionViajeAnexaRespuesta | undefined;
}

export enum EstadoPostulacionViajeTransportista {
    EnNegociacion = 0,
    Rechazada = 1,
    Aceptada = 2,
}

export interface PostulacionViajeAnexaRespuesta {
    /** Geo-punto codificado para representar en mapa la ubicación destino */
    UbicacionDestino?: string | undefined;
    /** Nombre de la dirección destino ingresada */
    DireccionUbicacionDestino?: string | undefined;
    /** Geo-punto codificado para representar en mapa la ubicación origen */
    UbicacionOrigen?: string | undefined;
    /** Nombre de la dirección origen ingresada */
    DireccionUbicacionOrigen?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    /** Fecha de salida propuesta para el viaje */
    FechaSalida: string;
    /** Estado en el que se encuentra la postulación */
    EstadoPostulacionViaje: EstadoPostulacionViaje;
    EstadoPostulacionViajeString?: string | undefined;
    /** Indica si el viaje se realizó mediante la aplicación móvil o no */
    ViajeRealizadoEnApp?: boolean | undefined;
}

export interface DescartarPostulacionPeticion {
    PostulacionViajeId: string;
    TransportistaId: string;
}

export interface ActualizarPostulacionTransportistaPeticion {
    Observaciones?: string | undefined;
    TransportistaId: string;
    PostulacionViajeId: string;
}

export interface PostulacionViajeTransportistaPeticion {
    TransportistaId: string;
    PostulacionViajeId: string;
}

export interface PostulacionViajeDetallesRespuesta extends PostulacionViajeRespuesta {
    ViajesRelacionados?: ObtenerViajesRelacionadosGridRespuesta[] | undefined;
}

export interface ObtenerViajesRelacionadosGridRespuesta {
    ViajeId: string;
    PostulacionViajeId: string;
    FechaSalida: string;
    FechaLlegada?: string | undefined;
    Clave?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
}

export interface ObtenerDetallesViajeRelacionadoRespuesta {
    Clave?: string | undefined;
    Alias?: string | undefined;
    Estado: EstadoViaje;
    EstadoString?: string | undefined;
    Categoria?: string | undefined;
    Subcategoria?: string | undefined;
    CategoriaId: string;
    EsContenedor: boolean;
    FechaSalida: string;
    FechaLlegada?: string | undefined;
    OrigenCliente?: string | undefined;
    DestinoCliente?: string | undefined;
    OrigenTransportista?: string | undefined;
    DestinoTransportista?: string | undefined;
    DireccionOrigenCliente?: string | undefined;
    DireccionDestinoCliente?: string | undefined;
    DireccionOrigenTransportista?: string | undefined;
    DireccionDestinoTransportista?: string | undefined;
    CargaConsolidada: boolean;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    ParadasIntermedias?: ParadaIntermediaPostulacionRespuesta[] | undefined;
    ParadaIntermediaCercanaOrigenId?: string | undefined;
    ParadaIntermediaCercanaDestinoId?: string | undefined;
    UbicacionCoincidenciaOrigen?: string | undefined;
    UbicacionCoincidenciaDestino?: string | undefined;
    DistanciaOrigen: number;
    DistanciaOrigenString?: string | undefined;
    DistanciaDestino: number;
    DistanciaDestinoString?: string | undefined;
    TiempoOrigen: number;
    TiempoDestino: number;
    EsDuenioPostulacion: boolean;
    SolicitudViajeId?: string | undefined;
}

export enum EstadoViaje {
    Pendiente = 0,
    Cancelado = 1,
    EnProceso = 2,
    Finalizado = 3,
}

export interface ParadaIntermediaPostulacionRespuesta {
    ParadaIntermediaId: string;
    Ubicacion?: string | undefined;
    SepomexId: string;
    FechaInicial: string;
    FechaFinal: string;
    Direccion?: string | undefined;
}

export interface RelacionarViajeExistenteRespuesta {
    ViajeId: string;
    PostulacionViajeId: string;
}

export interface RelacionarViajeExistentePeticion {
    ViajeId: string;
    PostulacionViajeId: string;
    UsuarioId?: string | undefined;
}

export interface ObtenerViajeSeleccionableRespuesta {
    ViajeId: string;
    Clave?: string | undefined;
    Fecha: string;
    DireccionUbicacionOrigen?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
}

export interface ObtenerRegimenFiscalSatConUsosCfdiSatRespuesta {
    /** Identificador único */
    RegimenFiscalSatId: string;
    /** Clave única */
    Clave?: string | undefined;
    /** Descripción general */
    Descripcion?: string | undefined;
    /** Para indicar si aplica a un ente físico */
    Fisica?: string | undefined;
    /** Para indicar si aplica a un ente moral */
    Moral?: string | undefined;
    EsGenerico: boolean;
    EsFisica: boolean;
    EsMoral: boolean;
    UsosCfdi?: ObtenerUsoCfdiSatRespuesta[] | undefined;
}

export interface ObtenerUsoCfdiSatRespuesta {
    /** Identificador único */
    UsoCfdiSatId: string;
    /** Clave única */
    Clave?: string | undefined;
    /** Descripcion general */
    Descripcion?: string | undefined;
    /** Para indicar si aplica a un ente moral */
    Moral?: string | undefined;
    EsGenerico: boolean;
    /** Para indicar si aplica a un ente físico */
    Fisica?: string | undefined;
    EsFisica: boolean;
    EsMoral: boolean;
}

export interface ObtenerRegimenFiscalSatRespuesta {
    RegimenFiscalSatId: string;
    /** Clave única */
    Clave?: string | undefined;
    /** Descripción general */
    Descripcion?: string | undefined;
    /** Para indicar si aplica a un ente físico */
    Fisica?: string | undefined;
    /** Para indicar si aplica a un ente moral */
    Moral?: string | undefined;
    EsGenerico: boolean;
    EsFisica: boolean;
    EsMoral: boolean;
}

export interface RegistrarReporteUbicacionSolicitudViajePeticion {
    Ubicacion?: string | undefined;
    DireccionUbicacion?: string | undefined;
    ViajeId: string;
}

export interface MercanciaSeguro {
    Id?: string | undefined;
    Descripcion?: string | undefined;
}

export interface SolicitarCotizacionRespuesta {
    respuesta: boolean;
    Mensaje?: string | undefined;
    Folio: number;
    suma_asegurada: number;
    Monto_cotizado: number;
    iva: number;
    total: number;
}

export interface SolicitarCotizacionPeticion {
    idtipo_cambio?: string | undefined;
    suma_asegurada?: string | undefined;
    idtipo_calculo?: string | undefined;
    idtipo_cotizacion?: string | undefined;
    idtipo_contenedor?: string | undefined;
}

export interface SolicitarTarifaContenedorRespuesta {
    respuesta: boolean;
    mensaje?: TarifaContenedor[] | undefined;
}

export interface TarifaContenedor {
    tipo_contenedor?: string | undefined;
    precio: number;
    iva: number;
    total: number;
}

export interface SolicitarSeguroMercanciaRespuesta {
    respuesta: boolean;
    suma_asegurada?: string | undefined;
    tarifa?: string | undefined;
    cuota_neta: number;
    iva: number;
    total: number;
    mensaje?: string | undefined;
    Base64_PDF?: string | undefined;
}

export interface SolicitarSeguroMercanciaPeticion {
    usuario?: string | undefined;
    pass?: string | undefined;
    folio_cotizacion: number;
    estado_mercancia?: string | undefined;
    mercancia: number;
    descripcion_mercancia?: string | undefined;
    id_tipo_conducto: number;
    fecha_salida?: string | undefined;
    fecha_arribo?: string | undefined;
    folio_referencia?: string | undefined;
    pais_origen?: string | undefined;
    estado_origen?: string | undefined;
    ciudad_origen?: string | undefined;
    pais_destino?: string | undefined;
    estado_destino?: string | undefined;
    ciudad_destino?: string | undefined;
}

export interface SolicitarSeguroContenedorRespuesta {
    respuesta: boolean;
    mensaje?: string | undefined;
    tipo_contenedor?: string | undefined;
    precio_contenedor: number;
    Base64_PDF?: string | undefined;
}

export interface SolicitarSeguroContenedorPeticion {
    id_tipo_contenedor?: string | undefined;
    contenedores?: string[] | undefined;
    tipo_operacion?: string | undefined;
}

export interface ObtenerDatosSolicitudViajeSeguroRespuesta {
    fecha_salida: string;
    fecha_arribo?: string | undefined;
    ciudad_origen?: string | undefined;
    estado_origen?: string | undefined;
    pais_origen?: string | undefined;
    ciudad_destino?: string | undefined;
    estado_destino?: string | undefined;
    pais_destino?: string | undefined;
}

export interface RegistrarSeguroPeticion {
    SolicitudViajeId: string;
    SeguroMercancia?: IncluirSeguroMercanciaPeticion | undefined;
    SeguroContenedor?: IncluirSeguroContenedorPeticion | undefined;
}

export interface IncluirSeguroPeticion {
    PdfBase64?: string | undefined;
    CiudadDestino?: string | undefined;
    NombreCliente?: string | undefined;
    CoberturaUno?: string | undefined;
    CiudadOrigen?: string | undefined;
    Detalles?: string | undefined;
    EstadoDestino?: string | undefined;
    EstadoOrigen?: string | undefined;
    FechaLlegada: string;
    FechaSalida: string;
    Folio?: string | undefined;
    Moneda?: string | undefined;
    PaisDestino?: string | undefined;
    PaisOrigen?: string | undefined;
    Rfc?: string | undefined;
    TotalSinIva: number;
    Iva: number;
    Total: number;
}

export interface IncluirSeguroMercanciaPeticion extends IncluirSeguroPeticion {
    MontoAsegurado: number;
    TipoMercancia: number;
    EstatusMercancia?: string | undefined;
    TipoConducto: TipoConducto;
    TipoCotizacion: TipoCotizacionMercancia;
    TipoContenedor?: TipoContenedor | undefined;
}

export enum TipoConducto {
    Terrestre = 1,
    Maritimo = 2,
    Aereo = 3,
    MaritimoTerrestre = 4,
    Ferrocarril = 5,
    Paqueteria = 6,
}

export enum TipoCotizacionMercancia {
    Mercancia = 1,
    MercanciaContenedor = 2,
}

export enum TipoContenedor {
    Ninguno = 0,
    Seco20 = 1,
    Refrigerado = 2,
    Seco40 = 3,
    IsoTanque = 4,
}

export interface IncluirSeguroContenedorPeticion extends IncluirSeguroPeticion {
    TipoContenedor: TipoContenedor;
    ClaveContenedor?: string | undefined;
    TipoOperacion?: string | undefined;
    TipoTransporte: TipoConducto;
}

export interface SepomexMunicipioRespuesta {
    SepomexId: string;
    Municipio?: string | undefined;
}

export interface RegistrarArchivoSolicitudViajePeticion {
    SolicitudId: string;
    ArchivoBase64?: string | undefined;
}

export interface SubirFacturasTransportistaPeticion {
    SolicitudViajeId: string;
    RutaFacturaXml?: string | undefined;
    RutaFacturaPdf?: string | undefined;
    TransportistaId: string;
}

export interface CodigoQrRespuesta {
    Base64?: string | undefined;
    TipoMime?: string | undefined;
}

/** Datos mostrados al devolver listados de solicitudes de viaje */
export interface SolicitudViajeRespuesta {
    SolicitudViajeId: string;
    EstadoSolicitud: EstadoSolicitudViaje;
    EstadoSolicitudString?: string | undefined;
    Aceptada: boolean;
    AceptaTerminosCondiciones: boolean;
    FechaRegistro: string;
    FechaActualizacion?: string | undefined;
    NombreOriginalViaje?: string | undefined;
    ClienteId?: string | undefined;
    EmailCliente?: string | undefined;
    TelefonoCliente?: string | undefined;
    PropietarioId: string;
    PropietarioUsuarioId?: string | undefined;
    EmailPropietarioViaje?: string | undefined;
    TelefonoPropietarioViaje?: string | undefined;
    UbicacionPuntoLlegada?: string | undefined;
    UbicacionPuntoPartida?: string | undefined;
    CostoAcordado: number;
    EsCargaAduana: boolean;
    ViajeId: string;
    CostoInicialViaje: number;
    CategoriaViajeId: string;
    Regateos?: InformacionRegateoRespuesta[] | undefined;
    Compra?: InformacionCompraRespuesta | undefined;
    DetalleEnvio?: SolicitudDetalleEnvioDetalleRespuesta | undefined;
    SeguroMercancia?: SeguroMercanciaRespuesta | undefined;
    SeguroContenedor?: SeguroContenedorRespuesta | undefined;
    ParadasIntermedias?: ParadaIntermediaRespuesta[] | undefined;
    DatosContactoCarga?: DatosContactoRespuesta | undefined;
    DatosContactoRecibe?: DatosContactoRespuesta | undefined;
    FacturaXmlBase64?: string | undefined;
    FacturaPdfBase64?: string | undefined;
    CodigoQrBase64?: string | undefined;
    DocumentosSolicitud?: DocumentoSolicitudRespuesta[] | undefined;
    Incidencias?: IncidenciaViajeRespuesta[] | undefined;
    UbicacionesCargamento?: ReporteUbicacionSolicitudViajeRespuesta[] | undefined;
    DatosSolicitudCompletada?: DatosSolicitudCompletadaRespuesta | undefined;
    Cliente?: SolicitudDetalleClienteRespuesta | undefined;
    FechaActualServidor: string;
    DistanciaLongitudOrigen: number;
    DistanciaTiempoOrigen: number;
    DistanciaLongitudDestino: number;
    DistanciaTiempoDestino: number;
    UbicacionCoincidenciaOrigen?: string | undefined;
    UbicacionCoincidenciaDestino?: string | undefined;
    EsNegociable: boolean;
    DireccionPuntoLlegada?: string | undefined;
    DireccionPuntoPartida?: string | undefined;
    ParadaIntermediaCercanaDestinoId?: string | undefined;
    ParadaIntermediaCercanaOrigenId?: string | undefined;
    SolicitudViajeFacturaCfdiId?: string | undefined;
    EvaluacionViaje?: EvaluacionSolicitudViajeRespuesta | undefined;
}

export interface InformacionRegateoRespuesta {
    RegateoId: string;
    FechaRegateo: string;
    Monto: number;
    EsCliente: boolean;
    Estado: EstadoSolicitudViajeNegociacion;
    EstadoString?: string | undefined;
    NombreClienteTransportista?: string | undefined;
}

export enum EstadoSolicitudViajeNegociacion {
    EnNegociacion = 0,
    Rechazada = 1,
    Aceptada = 2,
    ContraOfertada = 3,
}

export interface InformacionCompraRespuesta {
    CompraId: string;
    DescripcionCompra?: string | undefined;
    FechaApertura: string;
    Importe: number;
    EstaPagada: boolean;
    FechaLiquidacion?: string | undefined;
}

export interface SolicitudDetalleEnvioDetalleRespuesta {
    DetalleEnvioId: string;
    FechaRegistro: string;
    Descripcion?: string | undefined;
    TieneCajaTransportadora?: boolean | undefined;
    Ancho: number;
    UnidadMedidaAncho?: string | undefined;
    Alto: number;
    UnidadMedidaAlto?: string | undefined;
    Largo: number;
    UnidadMedidaLargo?: string | undefined;
    Peso: number;
    UnidadMedidaPeso?: string | undefined;
    Temperatura?: number | undefined;
    UnidadMedidaTemperatura?: string | undefined;
    FotoUnoBase64?: string | undefined;
    FotoDosBase64?: string | undefined;
    SustanciaPeligrosa?: SolicitudDetalleEnvioDetalleSustanciaPeligrosaRespuesta | undefined;
    TieneVacunas?: boolean | undefined;
    CajaTransportadora?: boolean | undefined;
}

export interface SolicitudDetalleEnvioDetalleSustanciaPeligrosaRespuesta {
    Clave?: string | undefined;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
}

export interface SeguroMercanciaRespuesta {
    SeguroMercanciaId: string;
    PdfBase64?: string | undefined;
    CiudadDestino?: string | undefined;
    NombreCliente?: string | undefined;
    CoberturaUno?: string | undefined;
    CiudadOrigen?: string | undefined;
    Detalles?: string | undefined;
    EstadoDestino?: string | undefined;
    EstadoOrigen?: string | undefined;
    FechaLlegada: string;
    FechaSalida: string;
    Folio?: string | undefined;
    EstatusMercancia?: string | undefined;
    Moneda?: string | undefined;
    PaisDestino?: string | undefined;
    PaisOrigen?: string | undefined;
    Rfc?: string | undefined;
    Total: number;
}

export interface SeguroContenedorRespuesta {
    SeguroContenedorId: string;
    PdfBase64?: string | undefined;
    CiudadDestino?: string | undefined;
    NombreCliente?: string | undefined;
    CoberturaUno?: string | undefined;
    CiudadOrigen?: string | undefined;
    Detalles?: string | undefined;
    EstadoDestino?: string | undefined;
    EstadoOrigen?: string | undefined;
    FechaLlegada: string;
    FechaSalida: string;
    Folio?: string | undefined;
    Moneda?: string | undefined;
    PaisDestino?: string | undefined;
    PaisOrigen?: string | undefined;
    Rfc?: string | undefined;
    TipoOperacion?: string | undefined;
    TipoTransporte?: string | undefined;
    Total: number;
}

export interface ParadaIntermediaRespuesta {
    ParadaIntermediaId: string;
    Ubicacion?: string | undefined;
    Direccion?: string | undefined;
    SepomexId: string;
    FechaInicio: string;
    FechaFin: string;
}

export interface RegistrarDatosContactoInfo {
    NombreContacto?: string | undefined;
    EmailContacto?: string | undefined;
    TelefonoContacto?: string | undefined;
    HoraInicio: string;
    HoraFin: string;
    RutaImagenTemporal?: string | undefined;
    ImagenBase64?: string | undefined;
}

export interface DatosContactoRespuesta extends RegistrarDatosContactoInfo {
    DatosContactoId: string;
}

export interface IncidenciaViajeRespuesta extends RegistrarIncidenciaViajePeticion {
    IncidenciaViajeId: string;
}

export interface ReporteUbicacionSolicitudViajeRespuesta extends RegistrarReporteUbicacionSolicitudViajePeticion {
    ReporteUbicacionSolicitudViajeId: string;
    FechaReporte: string;
}

export interface DatosSolicitudCompletadaRespuesta {
    DatosSolicitudCompletadaId: string;
    UbicacionFirma?: string | undefined;
    FechaFirmaRecibida: string;
    ImagenBase64?: string | undefined;
}

export interface SolicitudDetalleClienteRespuesta {
    FechaRegistro: string;
    UserName?: string | undefined;
    Email?: string | undefined;
    PhoneNumber?: string | undefined;
}

export interface EvaluacionSolicitudViajeRespuesta {
    CalificacionSatisfecho: number;
    CalificacionPrimeraOpcion: number;
    CalificacionTiempoAcordado: number;
    CalificacionEstadoMercancia: number;
    CalificacionRecomendacionRaiter: number;
    Comentario?: string | undefined;
}

export interface RegistrarSolicitudViajePeticion {
    UsuarioId?: string | undefined;
    UbicacionPuntoPartida?: string | undefined;
    UbicacionPuntoLlegada?: string | undefined;
    DireccionPuntoPartida?: string | undefined;
    DireccionPuntoLlegada?: string | undefined;
    Observaciones?: string | undefined;
    CuidadosEspeciales?: string | undefined;
    AceptaDecirVerdad: boolean;
    AceptaTerminosCondiciones: boolean;
    EsCargaAduana: boolean;
    ViajeId: string;
    CategoriaViajeId: string;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    DistanciaLongitudOrigen: number;
    DistanciaLongitudDestino: number;
    DistanciaTiempoOrigen: number;
    DistanciaTiempoDestino: number;
    UbicacionCoincidenciaOrigen?: string | undefined;
    UbicacionCoincidenciaDestino?: string | undefined;
    ParadaIntermediaCercanaOrigenId?: string | undefined;
    ParadaIntermediaCercanaDestinoId?: string | undefined;
    SeguroMercancia?: IncluirSeguroMercanciaPeticion | undefined;
    SeguroContenedor?: IncluirSeguroContenedorPeticion | undefined;
    DetalleEnvio?: DetalleEnvioPeticion | undefined;
}

export interface DetalleEnvioPeticion {
    Peso: number;
    UnidadMedidaPesoId?: string | undefined;
    TieneVacunas?: boolean | undefined;
    CajaTransportadora?: boolean | undefined;
    Ancho: number;
    UnidadMedidaAnchoId?: string | undefined;
    Alto: number;
    UnidadMedidaAltoId?: string | undefined;
    Largo: number;
    UnidadMedidaLargoId?: string | undefined;
    SustanciaPeligrosaId?: string | undefined;
    Temperatura?: number | undefined;
    UnidadMedidaTemperaturaId?: string | undefined;
    FotoUnoBase64?: string | undefined;
    FotoDosBase64?: string | undefined;
}

export interface ModificarEstadoSolicitudPeticion {
    TransportistaId: string;
    SolicitudId: string;
}

export interface RegistrarDatosContactoPeticion {
    SolicitudId: string;
    ContactoCarga?: RegistrarDatosContactoInfo | undefined;
    ContactoRecibe?: RegistrarDatosContactoInfo | undefined;
    RutaCodigoQr?: string | undefined;
}

export interface IniciarSolicitudViajePeticion {
    SolicitudViajeId: string;
    Comentario?: string | undefined;
    ImagenBase64?: string | undefined;
    Ubicacion?: string | undefined;
    Direccion?: string | undefined;
}

export interface CompletarSolicitudPeticion {
    SolicitudId: string;
    UbicacionFirma?: string | undefined;
    ImagenBase64?: string | undefined;
    EstadoMercancia: EstadoMercancia;
}

export enum EstadoMercancia {
    MercanciaCompleta = 0,
    MercanciaDaniada = 1,
    MercanciaIncompleta = 2,
    MercanciaIncompletaDaniada = 3,
}

export interface EvaluarViajePeticion {
    SolicitudId: string;
    CalificacionSatisfecho: number;
    CalificacionPrimeraOpcion: number;
    CalificacionTiempoAcordado: number;
    CalificacionEstadoMercancia: number;
    CalificacionRecomendacionRaiter: number;
    Comentario?: string | undefined;
}

export interface DatosAuxiliaresPagoSolicitudViajeRespuesta {
    SolicitudViajeId: string;
    ViajeId: string;
    ClaveViaje?: string | undefined;
    NombreEnvio?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    Costo: number;
    EstadoSolicitud: EstadoSolicitudViaje;
    EstadoSolicitudString?: string | undefined;
    FechaViaje: string;
    FechaLlegada?: string | undefined;
    UsuarioId?: string | undefined;
}

export interface SolicitudViajeRespuestaNuevo {
    SolicitudViajeId: string;
    DetallesViaje?: DatosGeneralesViajeRespuesta | undefined;
    DetallesSolicitud?: DatosGeneralesSolicitudRespuesta | undefined;
    DetalleEnvio?: DetalleEnvioRespuesta | undefined;
    /** Cliente no la ve, transportista si se pagó, admin sí */
    DetalleCliente?: DetalleClienteRespuesta | undefined;
    DetalleTransportista?: DetalleTransportistaRespuesta | undefined;
    DetalleSeguroMercancia?: DetalleSeguroMercanciaRespuesta | undefined;
    DetalleSeguroContenedor?: DetalleSeguroContenedorRespuesta | undefined;
    DetallePago?: DetallePagoRespuesta | undefined;
    ContactoCarga?: DetalleContactoRespuesta | undefined;
    ContactoRecibe?: DetalleContactoRespuesta | undefined;
    CodigoQr?: CodigoQrRespuesta | undefined;
    SucesosViaje?: SucesoViajeRespuesta[] | undefined;
    SolicitudViajePagoOpenpayId?: string | undefined;
    MercanciaRecibida: boolean;
    EvaluacionViaje?: EvaluacionSolicitudViajeRespuesta | undefined;
    DetalleCancelacion?: DetallesCancelacionSolicitudRespuesta | undefined;
    UltimasNegociaciones?: ObtenerNegociacionesRespuesta | undefined;
    DetalleSolicitudCompletada?: DatosSolicitudCompletadaRespuesta | undefined;
    DetalleSolicitudIniciada?: DetalleSolicitudIniciada | undefined;
    FacturaClienteId?: string | undefined;
}

export interface DatosGeneralesViajeRespuesta {
    Clave?: string | undefined;
    Nombre?: string | undefined;
    Estado: EstadoViaje;
    EstadoString?: string | undefined;
    DireccionOrigen?: string | undefined;
    DireccionDestino?: string | undefined;
    FechaSalidaEstimada: string;
    FechaLlegadaEstimada?: string | undefined;
    CostoInicial: number;
    EsNegociable: boolean;
    EsConsolidado: boolean;
    ViajeId: string;
    UbicacionOrigen?: string | undefined;
    UbicacionDestino?: string | undefined;
}

export interface DatosGeneralesSolicitudRespuesta {
    FechaRegistro: string;
    Estado: EstadoSolicitudViaje;
    TipoVista: TipoVistaSolicitud;
    InformacionContactoCargada: boolean;
    EstadoString?: string | undefined;
    MiDireccionOrigen?: string | undefined;
    MiDireccionDestino?: string | undefined;
    CostoAcordado: number;
    CostoTotal: number;
    CategoriaString?: string | undefined;
    CategoriaId: string;
    SubcategoriaString?: string | undefined;
    SubcategoriaId?: string | undefined;
    DireccionOrigenPuntoIntermedioCercano?: string | undefined;
    DireccionDestinoPuntoIntermedioCercano?: string | undefined;
    DistanciaPuntoOrigen: number;
    DistanciaPuntoDestino: number;
    TieneRegateos: boolean;
    FacturasTransportistaCargadas: boolean;
    EsCategoriaContenedor: boolean;
    RutaIniciada: boolean;
    UbicacionOrigen?: string | undefined;
    UbicacionDestino?: string | undefined;
    UbicacionOrigenPuntoIntermedio?: string | undefined;
    UbicacionDestinoPuntoIntermedio?: string | undefined;
    EsCargaAduanal: boolean;
}

export enum TipoVistaSolicitud {
    NoAutorizado = 0,
    Cliente = 1,
    DuenioViaje = 2,
    Chofer = 3,
    Administrador = 4,
}

export interface DetalleEnvioRespuesta {
    TieneCajaTransportadora?: boolean | undefined;
    TieneVacunas?: boolean | undefined;
    Ancho: number;
    UnidadMedidaAncho?: string | undefined;
    Alto: number;
    UnidadMedidaAlto?: string | undefined;
    Largo: number;
    UnidadMedidaLargo?: string | undefined;
    Peso: number;
    UnidadMedidaPeso?: string | undefined;
    Temperatura?: number | undefined;
    UnidadMedidaTemperatura?: string | undefined;
    FotoUnoBase64?: string | undefined;
    FotoDosBase64?: string | undefined;
    SustanciaPeligrosa?: string | undefined;
    Descripcion?: string | undefined;
    CuidadosEspeciales?: string | undefined;
}

export interface DetalleClienteRespuesta {
    FechaRegistro: string;
    NombreUsuario?: string | undefined;
    CorreoElectronico?: string | undefined;
    Telefono?: string | undefined;
}

export interface DetalleTransportistaRespuesta {
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    NombreComercial?: string | undefined;
    Telefono?: string | undefined;
    Email?: string | undefined;
}

export interface DetalleSeguroMercanciaRespuesta {
    Id?: string | undefined;
    MontoAsegurado: number;
    Folio?: string | undefined;
    Moneda?: string | undefined;
    Total: number;
    EstatusMercancia?: string | undefined;
    TipoMercanciaString?: string | undefined;
    TipoCotizacionString?: string | undefined;
    TipoContenedorString?: string | undefined;
    TipoConductoString?: string | undefined;
    Descripcion?: string | undefined;
}

export interface DetalleSeguroContenedorRespuesta {
    Id?: string | undefined;
    Folio?: string | undefined;
    Moneda?: string | undefined;
    Total: number;
    TipoContenedorString?: string | undefined;
    TipoOperacion?: string | undefined;
    TipoConductoString?: string | undefined;
    ClaveContenedor?: string | undefined;
}

export interface DetallePagoRespuesta {
    TipoPago: TipoPago;
    Monto: number;
    Moneda?: string | undefined;
    DescripcionPago?: string | undefined;
    EstadoPago?: string | undefined;
    Autorizacion?: string | undefined;
    Referencia?: string | undefined;
    FechaPago: string;
}

export enum TipoPago {
    Tarjeta = 0,
    ReferenciaBancaria = 1,
}

export interface DetalleContactoRespuesta {
    Nombre?: string | undefined;
    Email?: string | undefined;
    Telefono?: string | undefined;
    FechaInicio?: string | undefined;
    FechaFin?: string | undefined;
    HoraInicio: string;
    HoraFin: string;
    ImagenBase64?: string | undefined;
}

export interface SucesoViajeRespuesta {
    Titulo?: string | undefined;
    Cuerpo?: string | undefined;
    Fecha: string;
    TipoSuceso: TipoSucesoViaje;
    TipoIncidenciaString?: string | undefined;
    DireccionIncidencia?: string | undefined;
    UbicacionSuceso?: string | undefined;
    CancelaViaje: boolean;
    Retraso?: DatosRetrasoRespuesta | undefined;
}

export enum TipoSucesoViaje {
    InicioViaje = 0,
    EntregaMercancia = 1,
    ReporteUbicacion = 2,
    Incidencia = 3,
    Recepcion = 4,
}

export interface DatosRetrasoRespuesta {
    Dias: number;
    Horas: number;
    Minutos: number;
}

export interface DetallesCancelacionSolicitudRespuesta {
    FechaCancelacion: string;
    EntidadCancelo: EntidadCancelo;
    EntidadCanceloString?: string | undefined;
    MotivoCancelacion?: string | undefined;
}

export enum EntidadCancelo {
    Cliente = 0,
    Transportista = 1,
    Administrador = 2,
}

export interface ObtenerNegociacionesRespuesta {
    FechaSalidaViaje: string;
    EstadoViaje: EstadoViaje;
    EstadoSolicitudViaje: EstadoSolicitudViaje;
    Negociaciones?: ObtenerSolititudViajeNegociacion[] | undefined;
    /** Indicador para determinar si el usuario puede registrar la primera negociación */
    PuedeRealizarPrimeraNegociacion: boolean;
    /** Indicador para determinar si aun se puede realizar negociaciones, basandose en el plazo preconfigurado "HorasToleranciaPagoViaje" */
    EnPlazoParaNegociacion: boolean;
}

export interface ObtenerSolititudViajeNegociacion {
    SolicitudViajeNegociacionId: string;
    Monto: number;
    CostoInicial: number;
    EsCliente: boolean;
    NombreOfertante?: string | undefined;
    FechaPublicacion: string;
    Estado: EstadoSolicitudViajeNegociacion;
    EstadoString?: string | undefined;
    PuedeOfertar: boolean;
}

export interface DetalleSolicitudIniciada {
    DatosSolicitudIniciadaId: string;
    Direccion?: string | undefined;
    Ubicacion?: string | undefined;
    Comentario?: string | undefined;
    ImagenBase64?: string | undefined;
}

export interface ObtenerDatosContactoEdicionRespuesta {
    ContactoCarga?: DetalleContactoRespuesta | undefined;
    ContactoRecibe?: DetalleContactoRespuesta | undefined;
    CodigoQrCargado: boolean;
}

export interface ObtenerMisViajesPendientesRespuesta {
    SolicitudViajeId: string;
    Nombre?: string | undefined;
    Clave?: string | undefined;
    CostoAcordado: number;
    Fecha: string;
    FechaLlegada?: string | undefined;
    EstadoSolicitud: EstadoSolicitudViaje;
    Salida?: string | undefined;
    Llegada?: string | undefined;
    EstadoSolicitudString?: string | undefined;
}

export interface CancelarSolicitudViajePeticion {
    SolicitudViajeId: string;
    Motivo?: string | undefined;
    UsuarioId?: string | undefined;
}

export interface ObtenerDetallesCancelacionSolicitudRespuesta {
    ClaveViaje?: string | undefined;
    FechaSalida: string;
    EstadoSolicitud: EstadoSolicitudViaje;
    EstadoSolicitudString?: string | undefined;
    PuedeCancelarse: boolean;
    Acciones?: string[] | undefined;
}

export interface ObtenerDetallesCancelacionSolicitudPagoRespuesta extends DetallesCancelacionSolicitudRespuesta {
    SolicitudViajePagoOpenpayId?: string | undefined;
}

export interface RegistrarSolicitudViajeNegociacionPeticion {
    SolicitudViajeId: string;
    Monto: number;
    MontoAnterior: number;
    UsuarioId?: string | undefined;
    /** Representa el identificador unico de la negociacion en la cual se baso para realizar una contra oferta */
    SolicitudViajeNegociacionId?: string | undefined;
}

export interface SolicitudViajeNegociacionPeticion {
    SolicitudViajeNegociacionId: string;
    UsuarioId?: string | undefined;
}

export interface EditarSustanciaPeligrosaPeticion {
    SustanciaPeligrosaId: string;
    Clave?: string | undefined;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    NombreImagenSustanciaPeligrosa?: string | undefined;
    RequiereDescripcion: boolean;
    RequiereTemperatura: boolean;
}

export interface SustanciaPeligrosaRespuesta extends EditarSustanciaPeligrosaPeticion {
    FechaRegistro?: string | undefined;
    ImagenBase64?: string | undefined;
}

export interface RegistrarSustanciaPeligrosaPeticion {
    Clave?: string | undefined;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    NombreImagenSustanciaPeligrosa?: string | undefined;
    RequiereDescripcion: boolean;
    RequiereTemperatura: boolean;
}

export interface TipoUnidadTransporteRespuesta {
    Id: string;
    FechaRegistro: string;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    Tipo: TipoTransporte;
    RequiereAlto: boolean;
    RequiereAncho: boolean;
    RequiereLargo: boolean;
    RequierePeso: boolean;
    RequiereTemperatura: boolean;
    RequiereSustanciaPeligrosa: boolean;
    RequiereEsEstibable: boolean;
    TipoString?: string | undefined;
}

export enum TipoTransporte {
    Caja_Seca = 0,
    Porta_Contenedor = 1,
    Camion = 2,
    No_Se_Que_Necesito = 3,
}

export interface TipoUnidadTransporteRegistrarPeticion {
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    Tipo: TipoTransporte;
    RequiereAlto: boolean;
    RequiereAncho: boolean;
    RequiereLargo: boolean;
    RequierePeso: boolean;
    RequiereTemperatura: boolean;
    RequiereSustanciaPeligrosa: boolean;
}

export interface TipoUnidadTransporteEditarPeticion {
    Id: string;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    Tipo: TipoTransporte;
    RequiereAlto: boolean;
    RequiereAncho: boolean;
    RequiereLargo: boolean;
    RequierePeso: boolean;
    RequiereTemperatura: boolean;
    RequiereSustanciaPeligrosa: boolean;
    EntidadModificoId?: string | undefined;
    EntidadModifico?: string | undefined;
}

export interface TransportistaRespuestaGrid {
    TransportistaId: string;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    Email?: string | undefined;
    Telefono?: string | undefined;
    NombreComercial?: string | undefined;
    UrlPaginaWeb?: string | undefined;
    RazonSocial?: string | undefined;
    Rfc?: string | undefined;
    CuentaBancaria?: string | undefined;
    UsuarioId?: string | undefined;
    EstaActivo: boolean;
    FechaRegistro: string;
    Choferes?: ConsultaChoferRespuestaGrid[] | undefined;
    EstadoVerificacion: EstadoAprobacionTransportista;
    EstadoVerificacionString?: string | undefined;
    FechaActualizacionEstadoVerificacion?: string | undefined;
    ComentariosVerificacion?: string | undefined;
}

export interface TransportistaRespuesta extends TransportistaRespuestaGrid {
    FotoPerfilBase64?: string | undefined;
    FotoBannerBase64?: string | undefined;
    ViajesPublicados?: TransportistaViajeRespuesta[] | undefined;
}

export interface TransportistaViajeRespuesta {
    ViajeId: string;
    Alias?: string | undefined;
    Ruta?: string | undefined;
    CostoInicial: number;
    UbicacionDestino?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    UbicacionOrigen?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    Fecha: string;
    TieneParadasIntermedias: boolean;
}

export interface RegistrarTransportistaPeticion {
    /** Usuario al que se asocia este nuevo transportista */
    UsuarioId?: string | undefined;
    /** Indica si el transportista que se registra es autónomo o tendrá a su cargo a otros choferes en representación de la empresa */
    EsAutonomo: boolean;
    /** Nombre comercial al que representa el transportista */
    NombreComercial?: string | undefined;
    /** URL de la empresa del transportista */
    UrlPaginaWeb?: string | undefined;
    /** Razón social del transportista o de la empresa donde labora */
    RazonSocial?: string | undefined;
    /** Rfc del transportista o de la empresa donde se encuentra éste */
    Rfc?: string | undefined;
    /** Nombre de la foto de perfil devuelto por el endpoint que sube esta foto en caso de registrarse en el portal web */
    NombreFotoPerfil?: string | undefined;
    /** Nombre de la foto de banner devuelto por el endpoint que sube esta foto en caso de registrarse en el portal web */
    NombreFotoBanner?: string | undefined;
    /** Foto de perfil en base64, usar este campo en caso de subir la foto desde la aplicación móvil */
    FotoPerfilBase64?: string | undefined;
    /** Foto de banner en base64, usar este campo en caso de subir la foto desde la aplicación móvil */
    FotoBannerBase64?: string | undefined;
    /** Teléfono del transportista */
    Telefono?: string | undefined;
    /** Campo requerido para los transportistas autonomos para que registren su propia información de chofer */
    InformacionChofer?: DatosTransportistaChoferPeticion | undefined;
}

/** Datos de chofer para los transportistas autónomos */
export interface DatosTransportistaChoferPeticion {
    Ife?: string | undefined;
    NoLicencia?: string | undefined;
    TipoLicencia?: string | undefined;
    FechaNacimiento?: string | undefined;
    /** Nombre de archivo de la imagen de perfil del chofer dentro de su ubicación temporal */
    DatosFotoPerfil?: string | undefined;
    /** Nombre de archivo de la imagen frontal de la credencial de elector en ubicación temporal */
    DatosFotoIfeFrente?: string | undefined;
    /** Nombre de archivo de la imagen del reverso de la credencial de elector en ubicación temporal */
    DatosFotoIfeReverso?: string | undefined;
    /** Nombre de archivo de la imagen frontal de la licencia de conducir en ubicación temporal */
    DatosFotoLicenciaFrente?: string | undefined;
    /** Nombre de archivo de la imagen del reverso de la licencia de conducir en ubicación temporal */
    DatosFotoLicenciaReverso?: string | undefined;
    /** Imagen en base64 */
    DatosFotoPerfilBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoIfeFrenteBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoIfeReversoBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoLicenciaFrenteBase64?: string | undefined;
    /** Imagen en base64 */
    DatosFotoLicenciaReversoBase64?: string | undefined;
}

export interface RegistrarTransportistaWebPeticion {
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    NombreComercial?: string | undefined;
    PaginaWeb?: string | undefined;
    RepresentanteLegal?: string | undefined;
    Domicilio?: string | undefined;
    Telefono?: string | undefined;
    ImagenEmpresaRuta?: string | undefined;
    ImagenBannerRuta?: string | undefined;
    ImagenIneFrenteRuta?: string | undefined;
    ImagenIneReversoRuta?: string | undefined;
    ActaConstitutivaRuta?: string | undefined;
    ComprobanteDomicilioRuta?: string | undefined;
    CuentaBancaria?: string | undefined;
}

export interface RegistrarTransportistaAppPeticion {
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    NombreComercial?: string | undefined;
    PaginaWeb?: string | undefined;
    RepresentanteLegal?: string | undefined;
    Domicilio?: string | undefined;
    Telefono?: string | undefined;
    ImagenEmpresaBase64?: string | undefined;
    ImagenBannerBase64?: string | undefined;
    ImagenIneFrenteBase64?: string | undefined;
    ImagenIneReversoBase64?: string | undefined;
    ActaConstitutivaBase64?: string | undefined;
    ComprobanteDomicilioBase64?: string | undefined;
    ActaConstitutivaExtension: ExtensionArchivo;
    ComprobanteDomicilioExtension: ExtensionArchivo;
    CuentaBancaria?: string | undefined;
}

export enum ExtensionArchivo {
    PDF = 0,
    PNG = 1,
    JPEG = 2,
    JPG = 3,
    BMP = 4,
    TXT = 5,
    DOC = 6,
    DOCX = 7,
}

export interface EditarTransportistaPeticion {
    TransportistaId: string;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    Telefono?: string | undefined;
    NombreComercial?: string | undefined;
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    PaginaWeb?: string | undefined;
    NombreFotoPerfil?: string | undefined;
    FotoPerfilBase64?: string | undefined;
    NombreFotoBanner?: string | undefined;
    FotoBannerBase64?: string | undefined;
}

export interface ObtenerMisDatosTransportistaRespuesta {
    Email?: string | undefined;
    Rfc?: string | undefined;
    RazonSocial?: string | undefined;
    NombreComercial?: string | undefined;
    PaginaWeb?: string | undefined;
    RepresentanteLegal?: string | undefined;
    Domicilio?: string | undefined;
    Telefono?: string | undefined;
    ImagenEmpresaBase64?: string | undefined;
    ImagenBannerBase64?: string | undefined;
    ImagenIneFrenteBase64?: string | undefined;
    ImagenIneReversoBase64?: string | undefined;
    ActaConstitutivaBase64?: string | undefined;
    ComprobanteDomicilioBase64?: string | undefined;
    ActaConstitutivaMime?: string | undefined;
    ComprobanteDomicilioMime?: string | undefined;
}

export interface ObtenerEstadosVerificacionTransportistaCombo {
    Estado: EstadoAprobacionTransportista;
    Descripcion?: string | undefined;
}

export interface ActualizarEstadoVerificacionTransportistaPeticion {
    TransportistaId: string;
    Estado: EstadoAprobacionTransportista;
    Comentarios?: string | undefined;
}

export interface EstadoVerificacionRespuesta {
    Email?: string | undefined;
    EstadoVerificacion: EstadoAprobacionTransportista;
    Comentarios?: string | undefined;
    EstadoVerificacionString?: string | undefined;
    FechaActualizacionEstado?: string | undefined;
}

export interface ObtenerComentarioTransportistaRespuesta {
    FechaRegistro: string;
    Comentario?: string | undefined;
    NombreUsuario?: string | undefined;
    CalificacionSatisfecho: number;
}

export interface EditarUnidadMedidaPeticion {
    UnidadMedidaId: string;
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    Abreviacion?: string | undefined;
}

export interface UnidadMedidaRespuesta extends EditarUnidadMedidaPeticion {
    FechaRegistro?: string | undefined;
}

export interface RegistrarUnidadMedidaPeticion {
    Nombre?: string | undefined;
    Descripcion?: string | undefined;
    Abreviacion?: string | undefined;
}

export enum TipoUnidadMedida {
    Peso = 0,
    Longitud = 1,
    Temperatura = 2,
}

export interface UnidadTransporteRespuesta {
    UnidadTransporteId: string;
    CargaMaxima: number;
    NumeroEjes: number;
    Modelo?: string | undefined;
    NumeroPlacas?: string | undefined;
    NumeroEconomico?: string | undefined;
    TipoUnidadTransporteUnidadId: string;
    PropietarioId?: string | undefined;
    FotoUnoBase64?: string | undefined;
    FotoDosBase64?: string | undefined;
    CategoriasIds?: string[] | undefined;
}

export interface UnidadTransporteRegistrarPeticion {
    CargaMaxima: number;
    NumeroEjes: number;
    Modelo?: string | undefined;
    NumeroPlacas?: string | undefined;
    TipoUnidadTransporteUnidadId: string;
    PropietarioId?: string | undefined;
    NumeroEconomico?: string | undefined;
    DatosFotoUno?: string | undefined;
    DatosFotoDos?: string | undefined;
    DatosFotoUnoBase64?: string | undefined;
    DatosFotoDosBase64?: string | undefined;
    CategoriasIds?: string[] | undefined;
}

export interface UnidadTransporteEditarPeticion {
    UnidadTransporteId: string;
    CargaMaxima: number;
    NumeroEjes: number;
    Modelo?: string | undefined;
    NumeroPlacas?: string | undefined;
    NumeroEconomico?: string | undefined;
    TipoUnidadTransporteUnidadId: string;
    PropietarioId?: string | undefined;
    DatosFotoUno?: string | undefined;
    DatosFotoDos?: string | undefined;
    CategoriasIds?: string[] | undefined;
}

export interface ObtenerUnidadesTransportePorUsuarioRespuesta {
    UnidadTransporteId: string;
    CargaMaxima: number;
    NumeroEjes: number;
    Modelo?: string | undefined;
    NumeroPlacas?: string | undefined;
    NumeroEconomico?: string | undefined;
    TipoUnidadTransporteUnidadId: string;
    PropietarioId?: string | undefined;
    CategoriasIds?: string[] | undefined;
    CategoriasString?: string[] | undefined;
    FotoUnoBase64?: string | undefined;
    FotoDosBase64?: string | undefined;
}

/** Clase con campos para el registro de un nuevo usuario */
export interface RegistroUsuarioPeticion {
    /** Campo UserName para el usuario */
    NombreUsuario?: string | undefined;
    /** Nombre del usuario */
    Nombre?: string | undefined;
    /** Apellido paterno del usuario */
    Paterno?: string | undefined;
    /** Apellido materno del usuario */
    Materno?: string | undefined;
    /** Correo electrónico del usuario */
    Email?: string | undefined;
    /** Rol para el usuario */
    Rol?: string | undefined;
    /** Número de teléfono para el usuario */
    NumeroTelefono?: string | undefined;
    /** Contraseña para el usuario */
    Contrasenia?: string | undefined;
    /** Confirmación de la contrasenia */
    RepetirContrasenia?: string | undefined;
}

export interface RegistroUsuarioWebPeticion {
    /** Campo UserName para el usuario */
    NombreUsuario?: string | undefined;
    /** Nombre del usuario */
    Nombre?: string | undefined;
    /** Apellido paterno del usuario */
    Paterno?: string | undefined;
    /** Apellido materno del usuario */
    Materno?: string | undefined;
    /** Correo electrónico del usuario */
    Email?: string | undefined;
    /** Número de teléfono para el usuario */
    NumeroTelefono?: string | undefined;
    /** Contraseña para el usuario */
    Contrasenia?: string | undefined;
    /** Confirmación de la contrasenia */
    RepetirContrasenia?: string | undefined;
    FolioAmotac?: string | undefined;
    ClaveEstadoAmotac?: string | undefined;
}

export interface InicioSesionPeticion {
    Email?: string | undefined;
    Contrasenia?: string | undefined;
}

export interface EditarUsuarioPeticion extends RegistroUsuarioPeticion {
    Id?: string | undefined;
}

export interface RestablecerContraseniaPeticion {
    UsuarioId?: string | undefined;
    Token?: string | undefined;
    NuevaContrasenia?: string | undefined;
    RepetirContrasenia?: string | undefined;
}

export interface ObtenerMisDatosRespuesta {
    Id?: string | undefined;
    Email?: string | undefined;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    Telefono?: string | undefined;
}

export interface CambiarPasswordPeticion {
    Id?: string | undefined;
    ContraseniaActual?: string | undefined;
    ContraseniaNueva?: string | undefined;
}

export interface ConfirmarEmailRespuesta {
    Exito: boolean;
    Mensaje?: string | undefined;
    Email?: string | undefined;
}

export interface RegistrarViajePeticion {
    Clave?: string | undefined;
    Alias?: string | undefined;
    /** Array de ubicaciones */
    Ruta?: string | undefined;
    PropietarioViajeId: string;
    ViajeChoferes?: string[] | undefined;
    CostoInicial: number;
    CostoEspacioPesoConsolidado?: number | undefined;
    UbicacionDestino?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    UbicacionOrigen?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    Fecha: string;
    EsConsolidado: boolean;
    EsNegociable: boolean;
    ParadasIntermedias?: RegistrarParadaIntermediaPeticion[] | undefined;
    VehiculoId: string;
    FechaLlegada?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    /** Hace referencia a la postulación relacionada. Flujo POSTULACION->VIAJE->SOLICITUD */
    PostulacionViajeId?: string | undefined;
}

export interface RegistrarParadaIntermediaPeticion {
    Ubicacion?: string | undefined;
    Direccion?: string | undefined;
    FechaInicio: string;
    FechaFin: string;
    SepomexId: string;
}

export interface EditarViajePeticion {
    ViajeId: string;
    Alias?: string | undefined;
    /** Array de ubicaciones */
    Ruta?: string | undefined;
    ViajeChoferes?: string[] | undefined;
    CostoInicial: number;
    CostoEspacioPesoConsolidado?: number | undefined;
    UbicacionDestino?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    UbicacionOrigen?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    Fecha: string;
    EsConsolidado: boolean;
    EsNegociable: boolean;
    ParadasIntermedias?: RegistrarParadaIntermediaPeticion[] | undefined;
    VehiculoId: string;
    FechaLlegada?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
}

export interface ObtenerViajesGridRespuesta {
    ViajeId: string;
    Clave?: string | undefined;
    /** Referencia al viaje (p.ej. Mexico-Queretaro) */
    Alias?: string | undefined;
    /** Conjunto de puntos codificados con maps, que representan la ruta del viaje */
    Ruta?: string | undefined;
    EstadoViaje: EstadoViaje;
    EstadoViajeString?: string | undefined;
    /** Identificador unico del usuario que registro el viaje */
    PropietarioViajeId: string;
    PropietarioViajeUsuarioId?: string | undefined;
    PropietarioString?: string | undefined;
    ViajeChoferes?: ViajeChoferRespuesta[] | undefined;
    CostoInicial: number;
    /** Geo-punto codificado para representar en mapa la ubicación destino */
    UbicacionDestino?: string | undefined;
    /** Nombre de la dirección destino ingresada */
    DireccionUbicacionDestino?: string | undefined;
    /** Geo-punto codificado para representar en mapa la ubicación origen */
    UbicacionOrigen?: string | undefined;
    /** Nombre de la dirección origen ingresada */
    DireccionUbicacionOrigen?: string | undefined;
    Fecha: string;
    TieneParadasIntermedias: boolean;
    EsConsolidado: boolean;
    EsNegociable: boolean;
    VehiculoId: string;
    TipoVehiculo?: string | undefined;
    CategoriaString?: string | undefined;
    FechaLlegada?: string | undefined;
    FechaLimiteSolicitud: string;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    ParadasIntermedias?: ParadaIntermediaRespuesta[] | undefined;
    CategoriaPadre?: CategoriaViajeDetalleRespuesta | undefined;
    CategoriaHija?: CategoriaViajeDetalleRespuesta | undefined;
}

export interface ViajeChoferRespuesta {
    ViajeChoferId: string;
    ChoferId: string;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    CorreoElectronico?: string | undefined;
    Telefono?: string | undefined;
    FotoPerfilBase64?: string | undefined;
    InformacionExtra?: string[] | undefined;
}

export interface CategoriaViajeDetalleRespuesta {
    CategoriaViajeId: string;
    Nombre?: string | undefined;
}

export interface DetallesViajeRespuesta {
    ViajeId: string;
    Fecha: string;
    Alias?: string | undefined;
    Clave?: string | undefined;
    EstadoViaje: EstadoViaje;
    EstadoViajeString?: string | undefined;
    Ruta?: string | undefined;
    CostoInicial: number;
    CostoEspacioPesoConsolidado: number;
    UbicacionDestino?: string | undefined;
    UbicacionOrigen?: string | undefined;
    TieneParadasIntermedias: boolean;
    EsConsolidado: boolean;
    EsNegociable: boolean;
    EsPropietario: boolean;
    DireccionUbicacionOrigen?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    FechaLlegada?: string | undefined;
    FechaLimiteSolicitud: string;
    FechaFinalizacion?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    PropietarioViaje?: PropietarioViajeDetalleRespuesta | undefined;
    Vehiculo?: VehiculoViajeDetalleRespuesta | undefined;
    ViajeChoferes?: ChoferesViajeDetalleRespuesta[] | undefined;
    Solicitudes?: SolicitudViajeDetalleGridRespuesta[] | undefined;
    ParadasIntermedias?: ParadaIntermediaRespuesta[] | undefined;
}

export interface PropietarioViajeDetalleRespuesta {
    PropietarioViajeId: string;
    PropietarioViajeUsuarioId?: string | undefined;
    UserName?: string | undefined;
}

export interface VehiculoViajeDetalleRespuesta {
    VehiculoId: string;
    Modelo?: string | undefined;
    NumeroPlacas?: string | undefined;
    NumeroEconomico?: string | undefined;
}

export interface ChoferesViajeDetalleRespuesta {
    ChoferId: string;
    Nombre?: string | undefined;
    Paterno?: string | undefined;
    Materno?: string | undefined;
    CorreoElectronico?: string | undefined;
    Telefono?: string | undefined;
    NumeroLicencia?: string | undefined;
    TipoLicencia?: string | undefined;
}

export interface SolicitudViajeDetalleGridRespuesta {
    SolicitudViajeId: string;
    FechaRegistro: string;
    NombreEnvio?: string | undefined;
    Cliente?: ClienteViajeDetalleGridRespuesta | undefined;
    EstadoSolicitud: EstadoSolicitudViaje;
    EstadoSolicitudString?: string | undefined;
    Observaciones?: string | undefined;
    DetallesEnvio?: DetalleEnvioDetalleGridRespuesta | undefined;
    Compra?: CompraViajeDetalleGridRespuesta | undefined;
}

export interface ClienteViajeDetalleGridRespuesta {
    UserName?: string | undefined;
    Telefono?: string | undefined;
}

export interface DetalleEnvioDetalleGridRespuesta {
    TieneCajaTransportadora?: boolean | undefined;
    Peso: number;
    UnidadMedidaPeso?: string | undefined;
}

export interface CompraViajeDetalleGridRespuesta {
    EstaPagada: boolean;
    Importe?: number | undefined;
    FechaPago?: string | undefined;
    PagoTarjetaId?: string | undefined;
    PagoReferenciaId?: string | undefined;
}

export interface ObtenerViajesGridRespuestaExtension extends ObtenerViajesGridRespuesta {
    /** Elemento que guarda la distancia, tiempo y costo de caseta en base a la busqueda de un punto en google */
    DistaciaDestino?: Element | undefined;
    /** Elemento que guarda la distancia, tiempo y costo de caseta en base a la busqueda de un punto en google */
    DistaciaOrigen?: Element | undefined;
    TotalSolicitudes: number;
    MunicipioOrigen?: string | undefined;
    MunicipioDestino?: string | undefined;
    CostoEspacioPesoConsolidado?: number | undefined;
    /** Solicitud de viaje del usuario que lo solicita en caso de que ya haya el usuario hecho alguna que no este rechazada aún, para redirigirlo a ver la solicitud en lugar de permitirle hacer otra */
    SolicitudViajeVigenteId?: string | undefined;
    /** Indica si el usuario ya sobre paso el limite de solicitudes rechazadas al viaje, en ese caso ya no podrá solicitar el viaje */
    LimiteSolicitudesRechazadas: boolean;
    /** Muestra los últimos cinco comentarios del transportista dueño del viaje en base a sus evaluaciones */
    ComentariosTransportista?: ObtenerComentarioTransportistaRespuesta[] | undefined;
}

export interface Element {
    indexPuntoReferencia: number;
    coordenadaPuntoReferencia?: string | undefined;
    direccionPuntoReferencia?: string | undefined;
    distance?: Distance | undefined;
    duration?: Distance | undefined;
    status?: string | undefined;
    fare?: Fare | undefined;
    PuntoCoordenadaId?: string | undefined;
}

export interface Distance {
    text?: string | undefined;
    value: number;
}

export interface Fare {
    currency?: string | undefined;
    value: number;
    text?: string | undefined;
}

/** Datos requeridos para realizar busquedas de viajes próximos por fecha */
export interface ObtenerViajesFechaCoordenadasPeticion {
    /** Fecha de salida deseada */
    fecha: string;
    /** Id de la categoria deseada */
    categoriaId: string;
    /** Punto de origen/salida deseado */
    origen?: string | undefined;
    sepomexOrigenId: string;
    sepomexDestinoId: string;
    /** Punto de destino deseado */
    destino?: string | undefined;
    /** Usuario que realiza la búsqueda */
    usuarioId?: string | undefined;
    kmBusqueda: number;
    transporteId?: string | undefined;
}

export interface PuedeRegistrarViajesRespuesta {
    TieneChoferes: boolean;
    TieneUnidadesTransporte: boolean;
    TieneViajesRegistrados: boolean;
    PuedeRegistrarViajes: boolean;
}

export interface ObtenerViajePropietarioApp {
    ViajeId: string;
    Clave?: string | undefined;
    /** Referencia al viaje (p.ej. Mexico-Queretaro) */
    Alias?: string | undefined;
    EstadoViaje: EstadoViaje;
    EstadoViajeString?: string | undefined;
    Fecha: string;
    EsConsolidado: boolean;
    TotalSolicitudes: number;
    SolicitudViajeVigenteId?: string | undefined;
    /** Indica si el usuario ya sobre paso el limite de solicitudes rechazadas al viaje, en ese caso ya no podrá solicitar el viaje */
    LimiteSolicitudesRechazadas: boolean;
}

export interface ObtenerDetallesViajeInteresRespuesta {
    Clave?: string | undefined;
    Alias?: string | undefined;
    Estado: EstadoViaje;
    EstadoString?: string | undefined;
    FechaSalida: string;
    FechaLlegada?: string | undefined;
    SepomexOrigenId: string;
    SepomexDestinoId: string;
    UbicacionOrigen?: string | undefined;
    UbicacionDestino?: string | undefined;
    DireccionUbicacionOrigen?: string | undefined;
    DireccionUbicacionDestino?: string | undefined;
    CargaConsolidada: boolean;
    Categorias?: string[] | undefined;
    ParadasIntermedias?: ParadaIntermediaRespuesta[] | undefined;
    SolicitudViajeId?: string | undefined;
    PropietarioViajeId?: string | undefined;
}

export interface ObtenerDistanciaViajeInteresRespuesta {
    OrigenCliente?: string | undefined;
    DestinoCliente?: string | undefined;
    OrigenTransportista?: string | undefined;
    DestinoTransportista?: string | undefined;
    ParadasIntermedias?: ParadaIntermediaPostulacionRespuesta[] | undefined;
    ParadaIntermediaCercanaOrigenId?: string | undefined;
    ParadaIntermediaCercanaDestinoId?: string | undefined;
    UbicacionCoincidenciaOrigen?: string | undefined;
    UbicacionCoincidenciaDestino?: string | undefined;
    DistanciaOrigen: number;
    DistanciaOrigenString?: string | undefined;
    DistanciaDestino: number;
    DistanciaDestinoString?: string | undefined;
    TiempoOrigen: number;
    TiempoDestino: number;
}

export interface ObtenerDistanciaViajeInteresPeticion {
    ViajeId: string;
    OrigenCliente?: string | undefined;
    DestinoCliente?: string | undefined;
}

export interface ObtenerDetallesViajeCancelacionRespuesta {
    ViajeId: string;
    Clave?: string | undefined;
    FechaSalida: string;
    FechaCancelacion?: string | undefined;
    MotivoCancelacion?: string | undefined;
    Nombre?: string | undefined;
    PuedeCancelar: boolean;
    Estado: EstadoViaje;
    EstadoString?: string | undefined;
    SolicitudesAcciones?: ObtenerDetallesViajeCancelacionSolicitudesRespuesta[] | undefined;
}

export interface ObtenerDetallesViajeCancelacionSolicitudesRespuesta {
    Fecha: string;
    Estado?: string | undefined;
    Accion?: string | undefined;
}

export interface CancelarViajePeticion {
    ViajeId: string;
    UsuarioId?: string | undefined;
    Motivo?: string | undefined;
}

export interface NotificarPosicionTrasportePeticion {
    Latitud: number;
    Longitud: number;
    ViajeId: string;
}

export interface Filter {

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}